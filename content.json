{"meta":{"title":"Zat's Blog","subtitle":"Zat 的自留地","description":"Have fun！","author":"Zhou Fang","url":"https://walkerzf.github.io","root":"/"},"pages":[{"title":"1","date":"2019-12-23T07:07:04.000Z","updated":"2020-10-22T15:15:45.944Z","comments":true,"path":"1/index.html","permalink":"https://walkerzf.github.io/1/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2020-10-22T15:15:45.944Z","updated":"2020-10-22T15:15:45.944Z","comments":false,"path":"/404.html","permalink":"https://walkerzf.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-22T15:15:45.944Z","updated":"2020-10-22T15:15:45.944Z","comments":false,"path":"about/index.html","permalink":"https://walkerzf.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-10-22T15:15:45.944Z","updated":"2020-10-22T15:15:45.944Z","comments":false,"path":"books/index.html","permalink":"https://walkerzf.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-22T15:15:45.944Z","updated":"2020-10-22T15:15:45.944Z","comments":false,"path":"categories/index.html","permalink":"https://walkerzf.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-10-22T15:15:45.944Z","updated":"2020-10-22T15:15:45.944Z","comments":true,"path":"links/index.html","permalink":"https://walkerzf.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-10-22T15:15:45.944Z","updated":"2020-10-22T15:15:45.944Z","comments":false,"path":"repository/index.html","permalink":"https://walkerzf.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-22T15:15:45.944Z","updated":"2020-10-22T15:15:45.944Z","comments":false,"path":"tags/index.html","permalink":"https://walkerzf.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"6.S081 Pgtbl Lab","slug":"PgtblLab","date":"2020-10-22T15:13:14.000Z","updated":"2020-10-22T15:15:45.944Z","comments":true,"path":"2020/10/22/PgtblLab/","link":"","permalink":"https://walkerzf.github.io/2020/10/22/PgtblLab/","excerpt":"","text":"Pgtbl Lab In this lab , we will explore the user page tables and kernel page table ,and modify or create a process‘s kernel page table to help simplify the functions that copy data from user space into the kernel space. The lab have three parts. Part 1 is simpler relatively,we need to print the valid pte in three-level page table. Part 2 and 3 can be seen as one part .In part 2 ,we need to copy a process’s page table which is identical to kernel page table ,and in part 3 ,we need to add user mapping to the process’s kernel page table . Part 1 print a page table In this part ,we need to print the first process ‘ page table ,so we can see the figure 1 ,which is the use address space .The user address space have several parts : text,data ,guard page , stack,trampoline and trapframe . From the function freewalk .which is recursively free page-table pages ,we can find that we need to recursively print the page table. And we have three-level depth page table , so we need a variable to record the depth of the recursion in the helper function. 123456789101112131415161718// Recursively free page-table pages.// All leaf mappings must already have been removed.void freewalk(pagetable_t pagetable)&#123; // there are 2^9 = 512 PTEs in a page table. for (int i = 0; i &lt; 512; i++)&#123; pte_t pte = pagetable[i]; if ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == 0)&#123; // this PTE points to a lower-level page table. uint64 child = PTE2PA(pte); freewalk((pagetable_t)child); pagetable[i] = 0; &#125; else if (pte &amp; PTE_V)&#123; panic(\"freewalk: leaf\"); &#125; &#125; kfree((void *)pagetable);&#125; We can have the function like these. 123456789101112131415161718192021222324//heplerfunction for vmprintvoid helpervmprint(pagetable_t pagetable, int level)&#123; if (level &gt; 2) return; for (int i = 0; i &lt; 512; i++)&#123; pte_t pte = pagetable[i]; if ((pte &amp; PTE_V))&#123; //this pte pointer to a lower-level page table uint64 child = PTE2PA(pte); for (int j = 0; j &lt;= level; j++)&#123; printf(\"..\"); if (j != level) printf(\" \"); &#125; printf(\"%d: pte %p pa %p\\n\", i, pte, child); helpervmprint((pagetable_t)child, level + 1); &#125; &#125;&#125;//function to help print the contents of a page tablevoid vmprint(pagetable_t pagetable)&#123; printf(\"page table %p\\n\", pagetable); helpervmprint(pagetable, 0);&#125; We can get the output like this. In the top-level page table ,we have two entry. The first entry corresponding 1GB address. In the bottom page table ,we have three entries ,corresponding the text and data ,guard page and stack. The second entry in top-level page table , corresponding the trampoline and tramframe . We have two interesting points. The reason about the text and data are mapped together not respectively only for simplicity. The trampoline and tramframe are mapped highest in va , but in page table ,they are in entry 255,not in 511,because although the riscv uses 39-bits,it actually uses 38 bits ( because if we use the 39th bit ,the 40th 41th 42th ..etc should be set All for simplicity! But still support for the future!) , so in the top-level page table ,we only have 8 bits, the highest bit is 255. 12345678910page table 0x0000000087f6e000..0: pte 0x0000000021fda801 pa 0x0000000087f6a000.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000 We actually can print the PTE_FLAG for each valid pte. Part 2 A kernel page table per process The lab is vert time-consuming ,because we are doing kernel programming which is difficult to track the bug and easy to make error. The points we should pay attention to : The xv6 code is specialized for kernel page table the kernel page table init kvminit happens in pricinit and virto_disc. the memory free-up In part 3 , we will add user mapping in process’s kernel page table to allow the kernel to dereference the user pointer. This scheme rely on the user virtual memory range not overlapping the range of the va that the kernel address uses for its own instructions and data . Xv6 uses virtual addresses that start at zero for user address spaces, and luckily the kernel’s memory starts at higher addresses. However, this scheme does limit the maximum size of a user process to be less than the kernel’s lowest virtual address. After the kernel has booted, that address is 0xC000000 in xv6, the address of the PLIC registers .You’ll need to modify xv6 to prevent user processes from growing larger than the PLIC address. Through the calculating , thekernel base is in entry 2 .And the PLIC is in entry zero ,anything above the PLIC.So any user mapping below the PLIC will be added into process’s kernel page table .And anything above that will be identical to the kernel page table. So the entry 1-511 we can share the same page table with the kernel page table . The entry zero should be unique in process’s kernel page table. This is called share solution. We could have the naive copy solution , when we switch in process , we copy the ,when we switch out ,we free up the page table . The init of process kernel page table12345678910111213141516171819202122232425262728//share the 1-511 entry and map the entry zero for process 's kernel page table init// helper function void kvmmapkern(pagetable_t pagetable, uint64 va, uint64 pa, uint64 sz, int perm)&#123; if (mappages(pagetable, va, sz, pa, perm) != 0) panic(\"kvmmap\");&#125;// according to the Q&amp;A Lecture 7pagetable_t kvmcreate()&#123; pagetable_t p = uvmcreate(); int i; // we share the 1-511 entry for (i = 1; i &lt; 512; i++) &#123; p[i] = kernel_pagetable[i]; &#125; //we map the entry 0 and indentical to the kernel page table, add explicitly //we need a helper function because in kvminit function we do not //have an argument pagetable kvmmapkern(p, UART0, UART0, PGSIZE, PTE_R | PTE_W); kvmmapkern(p, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); kvmmapkern(p, CLINT, CLINT, 0x10000, PTE_R | PTE_W); kvmmapkern(p, PLIC, PLIC, 0x400000, PTE_R | PTE_W); return p;&#125; The clean of process kernel page tableWhen we free the process’s kernel page table ,because entry 1-511 we share the same thing with the kernel page table ,so we do not need to free that memory . So we do free the lower level page table corresponding the entry zero. We can get medium level page table through the pagetable[0] , and free any valid pte and corresponding bottom level page table . 123456789101112131415161718192021222324//according to the Q&amp;A Lecture 7//a specialize kvmfree to match kvmcreate//because we share the 1-511 ,only entry to consider is entry 0//thus ,we only have one mid-level pagetable and possibly 512 bottom-level//we never have free the PA which is pointed by the bottom-level pte//because non were allocated by kvmcreatevoid kvmfree(pagetable_t pagetable, uint64 sz)&#123; pte_t pte = pagetable[0]; pagetable_t level1 = (pagetable_t)PTE2PA(pte); for (int i = 0; i &lt; 512; i++) &#123; pte_t p = level1[i]; if (p &amp; PTE_V) &#123; uint64 level2 = PTE2PA(p); kfree((void *) level2); level1[i] =0; &#125; &#125; kfree((void *)level1); kfree((void *)pagetable);&#125; According to the hints in part 2 ,we need to fix the scheduler() to load the process’s kernel page table when process is running ,when the no process is running ,the scheduler() will use the kernel page table. 1234567891011121314151617&#123; // Switch to chosen process. It is the process's job // to release its lock and then reacquire it // before jumping back to us. p-&gt;state = RUNNING; c-&gt;proc = p; w_satp(MAKE_SATP(p-&gt;kernelpgtbl)); sfence_vma(); swtch(&amp;c-&gt;context, &amp;p-&gt;context); // Process is done running for now. // It should have changed its p-&gt;state before coming back. c-&gt;proc = 0; w_satp(MAKE_SATP(kernel_pagetable)); sfence_vma(); found = 1; &#125; Part 3 Add user mappingTask: Simplify copyin/copyinstr Now for per process ,we have two page table: one is user page table and another is a copy for kernel page table . We want to help the simply copyin , when the kernel do not have user mapping ,the kernel needs to translate the va =&gt; pa in software .Your task is to add user mapping to the process’s kernel page table so that the kernel can dereference the user pointers directly. Advantages: Performance. When we need to move big bytes which can go out of PGSIZE , we need to walkaddr the va ,and move the pa .But when we have the correct user mapping ,we can using the page table. We can manipulate the user data freely .Eg . when we need to fix a file in a data structure ,we may need copy in and copy out 123456789101112131415161718192021222324252627282930313233343536//according to Q&amp;A lecture 7//copy ptes from the user pgtbl to process kernel pgtblvoid kvmmapuser(int pid, pagetable_t kpagetable, pagetable_t upagetable, uint64 newsz, uint64 oldsz)&#123; uint64 va; pte_t *upte; pte_t *kpte; if (newsz &gt; PLIC) panic(\"kvmmapuser:newsz too large\"); for (va = oldsz; va &lt; newsz; va += PGSIZE) &#123; upte = walk(upagetable, va, 0); //debug if (upte == 0) &#123; printf(\"kvmmapuser :0x%x 0x%x\\n\", va, newsz); panic(\"kvmmapuser:not upte\"); &#125; if ((*upte &amp; PTE_V) == 0) &#123; printf(\"kvmmapuser : no valid pte 0x%x 0x%x\\n\", va, newsz); panic(\"kvmmapuser:not valid upte\"); &#125; kpte = walk(kpagetable, va, 1); if (kpte == 0) panic(\"kvmmapuser:no kpte\"); *kpte = *upte; *kpte &amp;= ~(PTE_U | PTE_W | PTE_X); &#125; // if newsz &lt; oldsz clear ptes , not necessary //check p-&gt;sz will not use thess ptes for (va = newsz; va &lt; oldsz; va += PGSIZE)&#123; kpte = walk(kpagetable, va, 1); *kpte &amp;= ~PTE_V; &#125;&#125; When we add the kvmmapuser in fork , the third argument should be new process’s page table , because when we fork many times, the old process may exit ,the old process ‘s page table may be cleaned up. The course lab site :MIT 6.S081 pgtbl","categories":[{"name":"6.S081","slug":"6-S081","permalink":"https://walkerzf.github.io/categories/6-S081/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://walkerzf.github.io/tags/Lab/"}]},{"title":"Introduction","slug":"hello-world","date":"2020-10-15T12:14:25.000Z","updated":"2020-10-22T15:15:45.944Z","comments":true,"path":"2020/10/15/hello-world/","link":"","permalink":"https://walkerzf.github.io/2020/10/15/hello-world/","excerpt":"","text":"Welcome to Zat’s Blog.My name is Zhou Fang. Education 2015/9~2019/6 | BeiHang University | Electrical Engineering | Bachelor 2019/9~ | ZheJiang University | Electrical Engineering | Master ExperienceLink [Github][https://github.com/walkerzf]","categories":[{"name":"intro","slug":"intro","permalink":"https://walkerzf.github.io/categories/intro/"}],"tags":[{"name":"intro","slug":"intro","permalink":"https://walkerzf.github.io/tags/intro/"}]}],"categories":[{"name":"6.S081","slug":"6-S081","permalink":"https://walkerzf.github.io/categories/6-S081/"},{"name":"intro","slug":"intro","permalink":"https://walkerzf.github.io/categories/intro/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://walkerzf.github.io/tags/Lab/"},{"name":"intro","slug":"intro","permalink":"https://walkerzf.github.io/tags/intro/"}]}