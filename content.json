{"meta":{"title":"Zat's Blog","subtitle":"Zat 的自留地","description":"Have fun！","author":"Zhou Fang","url":"https://walkerzf.github.io","root":"/"},"pages":[{"title":"1","date":"2019-12-23T07:07:04.000Z","updated":"2020-11-20T06:46:55.421Z","comments":true,"path":"1/index.html","permalink":"https://walkerzf.github.io/1/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2020-11-20T06:46:55.421Z","updated":"2020-11-20T06:46:55.421Z","comments":false,"path":"/404.html","permalink":"https://walkerzf.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-20T06:46:55.421Z","updated":"2020-11-20T06:46:55.421Z","comments":false,"path":"about/index.html","permalink":"https://walkerzf.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-11-20T06:46:55.421Z","updated":"2020-11-20T06:46:55.421Z","comments":false,"path":"books/index.html","permalink":"https://walkerzf.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-20T06:46:55.421Z","updated":"2020-11-20T06:46:55.421Z","comments":false,"path":"categories/index.html","permalink":"https://walkerzf.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-11-20T06:46:55.421Z","updated":"2020-11-20T06:46:55.421Z","comments":true,"path":"links/index.html","permalink":"https://walkerzf.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-11-20T06:46:55.421Z","updated":"2020-11-20T06:46:55.421Z","comments":false,"path":"repository/index.html","permalink":"https://walkerzf.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-20T06:46:55.421Z","updated":"2020-11-20T06:46:55.421Z","comments":false,"path":"tags/index.html","permalink":"https://walkerzf.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"6.S081 FS Lab","slug":"FSLab","date":"2020-11-20T03:10:00.000Z","updated":"2020-11-20T06:46:55.421Z","comments":true,"path":"2020/11/20/FSLab/","link":"","permalink":"https://walkerzf.github.io/2020/11/20/FSLab/","excerpt":"","text":"FS LabIn this lab you will add large files and symbolic links to the xv6 file system. In the first part , you will make the max size of a file in xv6 much bigger through sacrifice a direct block and adding a doubly-indirect block. In the second part , you will add symbolic link to the file in xv6 .Symbolic links resembles hard links, but hard links are restricted to pointing to file on the same disk, while symbolic links can cross disk devices. This is a good exercise to know about the pathname lookup in xv6 Part 1 Large filesThe first 11 elements of ip-&gt;addrs[] should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when bigfile writes 65803 blocks . 1234567#define NDIRECT 11#define DDIRECT 12#define NINDIRECT (BSIZE / sizeof(uint))struct inode &#123; //...// uint addrs[NDIRECT+1+1];&#125;; bmap function need to handle the doubly-indirect block 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 uintbmap(struct inode *ip, uint bn)&#123; uint addr, *a; struct buf *bp; if (bn &lt; NDIRECT) &#123; if ((addr = ip-&gt;addrs[bn]) == 0) ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev); return addr; &#125; bn -= NDIRECT; if (bn &lt; NINDIRECT) &#123; // Load singly-indirect block, allocating if necessary. if ((addr = ip-&gt;addrs[NDIRECT]) == 0) ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev); bp = bread(ip-&gt;dev, addr); a = (uint *)bp-&gt;data; if ((addr = a[bn]) == 0) &#123; a[bn] = addr = balloc(ip-&gt;dev); log_write(bp); &#125; brelse(bp); return addr; &#125; // Load doubly-indirect block, allocating if necessary. bn -= NINDIRECT; //allocate if ((addr = ip-&gt;addrs[DDIRECT]) == 0) &#123; ip-&gt;addrs[DDIRECT] = addr = balloc(ip-&gt;dev); &#125; bp = bread(ip-&gt;dev, addr); a = (uint *)bp-&gt;data; //doubly-indirect block ,we need to allocate on the block int index = bn / NINDIRECT; for (int i = 0; i &lt;= index; i++) &#123; if ((addr = a[i]) == 0) &#123; a[i] = addr = balloc(ip-&gt;dev); //log write must be in the loop //because when we read we have not the fs syscall log_write(bp); &#125; &#125; brelse(bp); //read the exacyly indirect block , and allocate a block and write bn -= NINDIRECT * index; bp = bread(ip-&gt;dev, addr); a = (uint *)bp-&gt;data; if ((addr = a[bn]) == 0) &#123; a[bn] = addr = balloc(ip-&gt;dev); log_write(bp); &#125; brelse(bp); return addr; panic(\"bmap: out of range\");&#125; Make sure that struct inode and struct dinode have the same number of elements in their addrs[] arrays. We need to fix the struct dinode in the same way. itrunc function need to erase the content on the all block belonging to the inode or file 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Truncate inode (discard contents).// Caller must hold ip-&gt;lock.void itrunc(struct inode *ip)&#123; int i, j; struct buf *bp; uint *a; for (i = 0; i &lt; NDIRECT; i++) &#123; if (ip-&gt;addrs[i]) &#123; bfree(ip-&gt;dev, ip-&gt;addrs[i]); ip-&gt;addrs[i] = 0; &#125; &#125; if (ip-&gt;addrs[NDIRECT]) &#123; bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]); a = (uint *)bp-&gt;data; for (j = 0; j &lt; NINDIRECT; j++) &#123; if (a[j]) bfree(ip-&gt;dev, a[j]); &#125; brelse(bp); bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]); ip-&gt;addrs[NDIRECT] = 0; &#125; if (ip-&gt;addrs[DDIRECT]) &#123; bp = bread(ip-&gt;dev, ip-&gt;addrs[DDIRECT]); a = (uint *)bp-&gt;data; struct buf *b; uint * ba; for (i = 0; i &lt; NINDIRECT; i++) &#123; if (a[i]) &#123; b = bread(ip-&gt;dev, a[i]); ba = (uint *)b-&gt;data; for (j = 0; j &lt; NINDIRECT; j++)&#123; if(ba[j]) bfree(ip-&gt;dev,ba[j]); &#125; brelse(b); bfree(ip-&gt;dev,a[i]); a[i] = 0; &#125; &#125; brelse(bp); bfree(ip-&gt;dev, ip-&gt;addrs[DDIRECT]); ip-&gt;addrs[DDIRECT] = 0; &#125; ip-&gt;size = 0; iupdate(ip);&#125; Part 2 Symbolic linksIn this part of lab , we need to add a system call into xv6 , which is symbolic links i.e. soft link . The symbolic links wants we to creates a new file which type is still FD_INODE, but the inode&#39;s type is T_SYMBOLIC , so we in the system call we need to allocate a new inode ,and allocate a new block for the first direct block .and write the length of the path and the path string in the block. Because the size of the length must a four-byte variable ,which is convenient for the read data from the block. 12345678910111213141516171819202122232425// labfs symbolic system calluint64sys_symlink(void)&#123; char target[MAXPATH], path[MAXPATH]; // struct inode *dp; struct inode *ip; //struct buf * b; //char * c; if (argstr(0, target, MAXPATH) &lt; 0 || argstr(1, path, MAXPATH) &lt; 0) return -1; begin_op(); //create will have the lock for the inode ip if((ip = create(path,T_SYMLINK,0,0))==0)&#123; end_op(); return -1; &#125; int len = strlen(target); writei(ip,0,(uint64)&amp;len,0,sizeof(len)); writei(ip,0,(uint64)target,sizeof(len),len+1); iunlockput(ip); end_op(); return 0;&#125; In sys_open system call , we need to fix the function to handle the inode&#39;s type is T_SYMBOLIC. And we should return false when we in a circle! 1234567891011121314151617181920int depth = 0,len ; char next[MAXPATH+1]; if(!(omode&amp;O_NOFOLLOW))&#123; for( ; depth&lt;10 &amp;&amp; ip-&gt;type ==T_SYMLINK ;depth++)&#123; readi(ip,0,(uint64)&amp;len,0,sizeof(len)); readi(ip,0,(uint64)next,sizeof(len),len); next[len]= 0; iunlockput(ip); if((ip=namei(next))==0)&#123; end_op(); return -1; &#125; ilock(ip); &#125; &#125; if(depth&gt;=10)&#123; iunlockput(ip); end_op(); return -1; &#125;","categories":[{"name":"6.S081","slug":"6-S081","permalink":"https://walkerzf.github.io/categories/6-S081/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://walkerzf.github.io/tags/Lab/"}]},{"title":"6.S081 Traps Lab","slug":"TrapLab","date":"2020-10-28T12:00:00.000Z","updated":"2020-11-20T06:46:55.421Z","comments":true,"path":"2020/10/28/TrapLab/","link":"","permalink":"https://walkerzf.github.io/2020/10/28/TrapLab/","excerpt":"","text":"Trap LabThis lab explores how system calls are implemented using traps. Part 1 AssemblyThis part is a warm-up exercise to let you know a little more about Risc-v Assemble. Part 2 BacktraceA helper function in kernel . BackTrace helps us to print a list of functions calls on the stack. According to the hints ,we do it step by step. Using the r-tp to get the frame pointer of the current stack frame . Note that the return address lives at a fixed offset (-8) from the frame pointer of a stack frame, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer. The operation on the pointer. Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. If the fp not satisfied the one PGSIZE , the fp will at the bottom of the call stack 1234567891011121314151617// lab4 part2// backtracevoid backtrace(void)&#123; uint64 * currentfp = (uint64 *)r_fp(); uint64 up ; uint64 down ; do &#123; printf(\"%p\\n\", *(currentfp-1)); currentfp = (uint64*)(*(currentfp-2)); up = PGROUNDUP((uint64)currentfp); down = PGROUNDDOWN((uint64)currentfp); &#125; while (up-down==PGSIZE); &#125; Part 3 AlarmIn this part , we want to add two system call to xv6 . Once in user code we invoke system call , The mode will convert from user mode - &gt; kernel mode .`` ecall-&gt;usertrap-&gt;usertrapret-&gt;sret, after exiting the kernel mode ,thepcwill jump to thep-&gt;tramframe-&gt;epcwhich saves thesepc. So we know when to callhandlerfunction (time interrupt) , afterinterrupt we need to jump thehandlerfunction ,which means we fix the value inp-&gt;tramframe-&gt;epc` . The function pointer aka the address of the function ,aka the value of epc. In user code , we invoke sigalarm. In this system call implementation, we need to save the interval and function pointer in proc structure , an return user code , the p-&gt;tramfram-&gt;epc will be the next of ecall. When we have a timer interrupt ,we need the epc be the function pointer , for resuming the interrupted user code . Because usually we return the interrupted user code, this time ,we need to jump tohandler function ,we need to reserve the p-&gt;tramframe-&gt;* and change the p-&gt;tramframe-&gt;epc be the function pointer . In handler function ,we invoke sigreturn system call. In this implementation , we restore the saved registers when interrupted ,and jump to the original p-&gt;tramframe-&gt;epc resume the user code . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748if (which_dev == 2) &#123; p-&gt;pastedticks++; if ((p-&gt;pastedticks &gt; 0) &amp;&amp; (p-&gt;pastedticks == p-&gt;interval)) &#123; if (p-&gt;permisson == 1) &#123; p-&gt;permisson = 0; p-&gt;epc = p-&gt;trapframe-&gt;epc; p-&gt;ra = p-&gt;trapframe-&gt;ra; p-&gt;sp = p-&gt;trapframe-&gt;sp; p-&gt;gp = p-&gt;trapframe-&gt;gp; p-&gt;tp = p-&gt;trapframe-&gt;tp; p-&gt;t0 = p-&gt;trapframe-&gt;t0; p-&gt;t1 = p-&gt;trapframe-&gt;t1; p-&gt;t2 = p-&gt;trapframe-&gt;t2; p-&gt;s0 = p-&gt;trapframe-&gt;s0; p-&gt;s1 = p-&gt;trapframe-&gt;s1; p-&gt;a0 = p-&gt;trapframe-&gt;a0; p-&gt;a1 = p-&gt;trapframe-&gt;a1; p-&gt;a2 = p-&gt;trapframe-&gt;a2; p-&gt;a3 = p-&gt;trapframe-&gt;a3; p-&gt;a4 = p-&gt;trapframe-&gt;a4; p-&gt;a5 = p-&gt;trapframe-&gt;a5; p-&gt;a6 = p-&gt;trapframe-&gt;a6; p-&gt;a7 = p-&gt;trapframe-&gt;a7; p-&gt;s2 = p-&gt;trapframe-&gt;s2; p-&gt;s3 = p-&gt;trapframe-&gt;s3; p-&gt;s4 = p-&gt;trapframe-&gt;s4; p-&gt;s5 = p-&gt;trapframe-&gt;s5; p-&gt;s6 = p-&gt;trapframe-&gt;s6; p-&gt;s7 = p-&gt;trapframe-&gt;s7; p-&gt;s8 = p-&gt;trapframe-&gt;s8; p-&gt;s9 = p-&gt;trapframe-&gt;s9; p-&gt;s10 = p-&gt;trapframe-&gt;s10; p-&gt;s11 = p-&gt;trapframe-&gt;s11; p-&gt;t3 = p-&gt;trapframe-&gt;t3; p-&gt;t4 = p-&gt;trapframe-&gt;t4; p-&gt;t5 = p-&gt;trapframe-&gt;t5; p-&gt;t6 = p-&gt;trapframe-&gt;t6; p-&gt;trapframe-&gt;epc = p-&gt;handler; p-&gt;pastedticks = 0; &#125; &#125; yield(); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// added system calluint64sys_sigreturn(void)&#123; struct proc *p = myproc(); p-&gt;permisson = 1; p-&gt;trapframe-&gt;epc = p-&gt;epc; p-&gt;trapframe-&gt;ra = p-&gt;ra; p-&gt;trapframe-&gt;sp = p-&gt;sp; p-&gt;trapframe-&gt;gp = p-&gt;gp; p-&gt;trapframe-&gt;tp = p-&gt;tp; p-&gt;trapframe-&gt;t0 = p-&gt;t0; p-&gt;trapframe-&gt;t1 = p-&gt;t1; p-&gt;trapframe-&gt;t2 = p-&gt;t2; p-&gt;trapframe-&gt;s0 = p-&gt;s0; p-&gt;trapframe-&gt;s1 = p-&gt;s1; p-&gt;trapframe-&gt;a0 = p-&gt;a0; p-&gt;trapframe-&gt;a1 = p-&gt;a1; p-&gt;trapframe-&gt;a2 = p-&gt;a2; p-&gt;trapframe-&gt;a3 = p-&gt;a3; p-&gt;trapframe-&gt;a4 = p-&gt;a4; p-&gt;trapframe-&gt;a5 = p-&gt;a5; p-&gt;trapframe-&gt;a6 = p-&gt;a6; p-&gt;trapframe-&gt;a7 = p-&gt;a7; p-&gt;trapframe-&gt;s2 = p-&gt;s2; p-&gt;trapframe-&gt;s3 = p-&gt;s3; p-&gt;trapframe-&gt;s4 = p-&gt;s4; p-&gt;trapframe-&gt;s5 = p-&gt;s5; p-&gt;trapframe-&gt;s6 = p-&gt;s6; p-&gt;trapframe-&gt;s7 = p-&gt;s7; p-&gt;trapframe-&gt;s8 = p-&gt;s8; p-&gt;trapframe-&gt;s9 = p-&gt;s9; p-&gt;trapframe-&gt;s10 = p-&gt;s10; p-&gt;trapframe-&gt;s11 = p-&gt;s11; p-&gt;trapframe-&gt;t3 = p-&gt;t3; p-&gt;trapframe-&gt;t4 = p-&gt;t4; p-&gt;trapframe-&gt;t5 = p-&gt;t5; p-&gt;trapframe-&gt;t6 = p-&gt;t6; return 0;&#125;//added system calluint64sys_sigalarm(void)&#123; struct proc *p = myproc(); if (argint(0, &amp;(p-&gt;interval)) &lt; 0) return -1; if (argaddr(1, &amp;(p-&gt;handler)) &lt; 0) return -1; return 0;&#125;","categories":[{"name":"6.S081","slug":"6-S081","permalink":"https://walkerzf.github.io/categories/6-S081/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://walkerzf.github.io/tags/Lab/"}]},{"title":"6.S081 Pgtbl Lab","slug":"PgtblLab","date":"2020-10-22T15:13:14.000Z","updated":"2020-11-20T06:46:55.421Z","comments":true,"path":"2020/10/22/PgtblLab/","link":"","permalink":"https://walkerzf.github.io/2020/10/22/PgtblLab/","excerpt":"","text":"Pgtbl Lab In this lab , we will explore the user page tables and kernel page table ,and modify or create a process‘s kernel page table to help simplify the functions that copy data from user space into the kernel space. The lab have three parts. Part 1 is simpler relatively,we need to print the valid pte in three-level page table. Part 2 and 3 can be seen as one part .In part 2 ,we need to copy a process’s page table which is identical to kernel page table ,and in part 3 ,we need to add user mapping to the process’s kernel page table . Part 1 print a page table In this part ,we need to print the first process ‘ page table ,so we can see the figure 1 ,which is the use address space .The user address space have several parts : text,data ,guard page , stack,trampoline and trapframe . From the function freewalk .which is recursively free page-table pages ,we can find that we need to recursively print the page table. And we have three-level depth page table , so we need a variable to record the depth of the recursion in the helper function. 123456789101112131415161718// Recursively free page-table pages.// All leaf mappings must already have been removed.void freewalk(pagetable_t pagetable)&#123; // there are 2^9 = 512 PTEs in a page table. for (int i = 0; i &lt; 512; i++)&#123; pte_t pte = pagetable[i]; if ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == 0)&#123; // this PTE points to a lower-level page table. uint64 child = PTE2PA(pte); freewalk((pagetable_t)child); pagetable[i] = 0; &#125; else if (pte &amp; PTE_V)&#123; panic(\"freewalk: leaf\"); &#125; &#125; kfree((void *)pagetable);&#125; We can have the function like these. 123456789101112131415161718192021222324//heplerfunction for vmprintvoid helpervmprint(pagetable_t pagetable, int level)&#123; if (level &gt; 2) return; for (int i = 0; i &lt; 512; i++)&#123; pte_t pte = pagetable[i]; if ((pte &amp; PTE_V))&#123; //this pte pointer to a lower-level page table uint64 child = PTE2PA(pte); for (int j = 0; j &lt;= level; j++)&#123; printf(\"..\"); if (j != level) printf(\" \"); &#125; printf(\"%d: pte %p pa %p\\n\", i, pte, child); helpervmprint((pagetable_t)child, level + 1); &#125; &#125;&#125;//function to help print the contents of a page tablevoid vmprint(pagetable_t pagetable)&#123; printf(\"page table %p\\n\", pagetable); helpervmprint(pagetable, 0);&#125; We can get the output like this. In the top-level page table ,we have two entry. The first entry corresponding 1GB address. In the bottom page table ,we have three entries ,corresponding the text and data ,guard page and stack. The second entry in top-level page table , corresponding the trampoline and tramframe . We have two interesting points. The reason about the text and data are mapped together not respectively only for simplicity. The trampoline and tramframe are mapped highest in va , but in page table ,they are in entry 255,not in 511,because although the riscv uses 39-bits,it actually uses 38 bits ( because if we use the 39th bit ,the 40th 41th 42th ..etc should be set All for simplicity! But still support for the future!) , so in the top-level page table ,we only have 8 bits, the highest bit is 255. 12345678910page table 0x0000000087f6e000..0: pte 0x0000000021fda801 pa 0x0000000087f6a000.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000 We actually can print the PTE_FLAG for each valid pte. Part 2 A kernel page table per process The lab is vert time-consuming ,because we are doing kernel programming which is difficult to track the bug and easy to make error. The points we should pay attention to : The xv6 code is specialized for kernel page table the kernel page table init kvminit happens in pricinit and virto_disc. the memory free-up In part 3 , we will add user mapping in process’s kernel page table to allow the kernel to dereference the user pointer. This scheme rely on the user virtual memory range not overlapping the range of the va that the kernel address uses for its own instructions and data . Xv6 uses virtual addresses that start at zero for user address spaces, and luckily the kernel’s memory starts at higher addresses. However, this scheme does limit the maximum size of a user process to be less than the kernel’s lowest virtual address. After the kernel has booted, that address is 0xC000000 in xv6, the address of the PLIC registers .You’ll need to modify xv6 to prevent user processes from growing larger than the PLIC address. Through the calculating , thekernel base is in entry 2 .And the PLIC is in entry zero ,anything above the PLIC.So any user mapping below the PLIC will be added into process’s kernel page table .And anything above that will be identical to the kernel page table. So the entry 1-511 we can share the same page table with the kernel page table . The entry zero should be unique in process’s kernel page table. This is called share solution. We could have the naive copy solution , when we switch in process , we copy the ,when we switch out ,we free up the page table . The init of process kernel page table12345678910111213141516171819202122232425262728//share the 1-511 entry and map the entry zero for process 's kernel page table init// helper function void kvmmapkern(pagetable_t pagetable, uint64 va, uint64 pa, uint64 sz, int perm)&#123; if (mappages(pagetable, va, sz, pa, perm) != 0) panic(\"kvmmap\");&#125;// according to the Q&amp;A Lecture 7pagetable_t kvmcreate()&#123; pagetable_t p = uvmcreate(); int i; // we share the 1-511 entry for (i = 1; i &lt; 512; i++) &#123; p[i] = kernel_pagetable[i]; &#125; //we map the entry 0 and indentical to the kernel page table, add explicitly //we need a helper function because in kvminit function we do not //have an argument pagetable kvmmapkern(p, UART0, UART0, PGSIZE, PTE_R | PTE_W); kvmmapkern(p, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); kvmmapkern(p, CLINT, CLINT, 0x10000, PTE_R | PTE_W); kvmmapkern(p, PLIC, PLIC, 0x400000, PTE_R | PTE_W); return p;&#125; The clean of process kernel page tableWhen we free the process’s kernel page table ,because entry 1-511 we share the same thing with the kernel page table ,so we do not need to free that memory . So we do free the lower level page table corresponding the entry zero. We can get medium level page table through the pagetable[0] , and free any valid pte and corresponding bottom level page table . 123456789101112131415161718192021222324//according to the Q&amp;A Lecture 7//a specialize kvmfree to match kvmcreate//because we share the 1-511 ,only entry to consider is entry 0//thus ,we only have one mid-level pagetable and possibly 512 bottom-level//we never have free the PA which is pointed by the bottom-level pte//because non were allocated by kvmcreatevoid kvmfree(pagetable_t pagetable, uint64 sz)&#123; pte_t pte = pagetable[0]; pagetable_t level1 = (pagetable_t)PTE2PA(pte); for (int i = 0; i &lt; 512; i++) &#123; pte_t p = level1[i]; if (p &amp; PTE_V) &#123; uint64 level2 = PTE2PA(p); kfree((void *) level2); level1[i] =0; &#125; &#125; kfree((void *)level1); kfree((void *)pagetable);&#125; According to the hints in part 2 ,we need to fix the scheduler() to load the process’s kernel page table when process is running ,when the no process is running ,the scheduler() will use the kernel page table. 1234567891011121314151617&#123; // Switch to chosen process. It is the process's job // to release its lock and then reacquire it // before jumping back to us. p-&gt;state = RUNNING; c-&gt;proc = p; w_satp(MAKE_SATP(p-&gt;kernelpgtbl)); sfence_vma(); swtch(&amp;c-&gt;context, &amp;p-&gt;context); // Process is done running for now. // It should have changed its p-&gt;state before coming back. c-&gt;proc = 0; w_satp(MAKE_SATP(kernel_pagetable)); sfence_vma(); found = 1; &#125; Part 3 Add user mappingTask: Simplify copyin/copyinstr Now for per process ,we have two page table: one is user page table and another is a copy for kernel page table . We want to help the simply copyin , when the kernel do not have user mapping ,the kernel needs to translate the va =&gt; pa in software .Your task is to add user mapping to the process’s kernel page table so that the kernel can dereference the user pointers directly. Advantages: Performance. When we need to move big bytes which can go out of PGSIZE , we need to walkaddr the va ,and move the pa .But when we have the correct user mapping ,we can using the page table. We can manipulate the user data freely .Eg . when we need to fix a file in a data structure ,we may need copy in and copy out 123456789101112131415161718192021222324252627282930313233343536//according to Q&amp;A lecture 7//copy ptes from the user pgtbl to process kernel pgtblvoid kvmmapuser(int pid, pagetable_t kpagetable, pagetable_t upagetable, uint64 newsz, uint64 oldsz)&#123; uint64 va; pte_t *upte; pte_t *kpte; if (newsz &gt; PLIC) panic(\"kvmmapuser:newsz too large\"); for (va = oldsz; va &lt; newsz; va += PGSIZE) &#123; upte = walk(upagetable, va, 0); //debug if (upte == 0) &#123; printf(\"kvmmapuser :0x%x 0x%x\\n\", va, newsz); panic(\"kvmmapuser:not upte\"); &#125; if ((*upte &amp; PTE_V) == 0) &#123; printf(\"kvmmapuser : no valid pte 0x%x 0x%x\\n\", va, newsz); panic(\"kvmmapuser:not valid upte\"); &#125; kpte = walk(kpagetable, va, 1); if (kpte == 0) panic(\"kvmmapuser:no kpte\"); *kpte = *upte; *kpte &amp;= ~(PTE_U | PTE_W | PTE_X); &#125; // if newsz &lt; oldsz clear ptes , not necessary //check p-&gt;sz will not use thess ptes for (va = newsz; va &lt; oldsz; va += PGSIZE)&#123; kpte = walk(kpagetable, va, 1); *kpte &amp;= ~PTE_V; &#125;&#125; When we add the kvmmapuser in fork , the third argument should be new process’s page table , because when we fork many times, the old process may exit ,the old process ‘s page table may be cleaned up. The course lab site :MIT 6.S081 pgtbl","categories":[{"name":"6.S081","slug":"6-S081","permalink":"https://walkerzf.github.io/categories/6-S081/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://walkerzf.github.io/tags/Lab/"}]},{"title":"Introduction","slug":"hello-world","date":"2020-10-15T12:14:25.000Z","updated":"2020-11-20T06:46:55.421Z","comments":true,"path":"2020/10/15/hello-world/","link":"","permalink":"https://walkerzf.github.io/2020/10/15/hello-world/","excerpt":"","text":"Welcome to Zat’s Blog.My name is Zhou Fang. Education 2015/9~2019/6 | BeiHang University | Electrical Engineering | Bachelor 2019/9~ | ZheJiang University | Electrical Engineering | Master ExperienceLink [Github][https://github.com/walkerzf]","categories":[{"name":"intro","slug":"intro","permalink":"https://walkerzf.github.io/categories/intro/"}],"tags":[{"name":"intro","slug":"intro","permalink":"https://walkerzf.github.io/tags/intro/"}]}],"categories":[{"name":"6.S081","slug":"6-S081","permalink":"https://walkerzf.github.io/categories/6-S081/"},{"name":"intro","slug":"intro","permalink":"https://walkerzf.github.io/categories/intro/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://walkerzf.github.io/tags/Lab/"},{"name":"intro","slug":"intro","permalink":"https://walkerzf.github.io/tags/intro/"}]}