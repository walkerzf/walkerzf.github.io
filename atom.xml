<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zat&#39;s Blog</title>
  
  <subtitle>Zat 的自留地</subtitle>
  <link href="https://walkerzf.github.io/atom.xml" rel="self"/>
  
  <link href="https://walkerzf.github.io/"/>
  <updated>2020-10-21T15:27:17.565Z</updated>
  <id>https://walkerzf.github.io/</id>
  
  <author>
    <name>Zhou Fang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>6.S081 Pgtbl Lab</title>
    <link href="https://walkerzf.github.io/2020/10/21/PgtblLab/"/>
    <id>https://walkerzf.github.io/2020/10/21/PgtblLab/</id>
    <published>2020-10-21T15:27:17.565Z</published>
    <updated>2020-10-21T15:27:17.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pgtbl-Lab"><a href="#Pgtbl-Lab" class="headerlink" title="Pgtbl Lab"></a>Pgtbl Lab</h1><p>  In this lab , we will explore the user page tables and kernel page table ,and modify or create a process‘s kernel page table to help simplify the functions that copy data from user space into the kernel space.</p><p>  The lab have three parts. Part 1  is simpler relatively,we need to print the <strong>valid</strong> <code>pte</code> in three-level page table. Part 2 and 3 can be seen as one part .In part 2 ,we need to copy a process’s page table which is identical to kernel page table ,and in part 3 ,we need to add user mapping to the process’s kernel page table .</p><h2 id="Part-1-print-a-page-table"><a href="#Part-1-print-a-page-table" class="headerlink" title="Part 1 print a page table"></a>Part 1 print a page table</h2><p>  In this part ,we need to print the first process ‘ page table ,so we can see the figure 1 ,which is the use address space .The user address space have several parts : <code>text</code>,<code>data</code> ,<code>guard page</code> , <code>stack</code>,<code>trampoline</code> and <code>trapframe</code> .</p><p>  From the function <code>freewalk</code> .which is recursively free page-table pages ,we can find that we need to recursively print the page table. And we have three-level depth page table , so we need a variable to record the depth of the recursion in the helper function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freewalk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">"freewalk: leaf"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span> *)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  We can have the function like these.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//heplerfunction for vmprint</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helpervmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (level &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V))&#123;</span><br><span class="line">      <span class="comment">//this pte pointer to a lower-level page table</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= level; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">".."</span>);</span><br><span class="line">        <span class="keyword">if</span> (j != level)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d: pte %p pa %p\n"</span>, i, pte, child);</span><br><span class="line">      helpervmprint((<span class="keyword">pagetable_t</span>)child, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//function to help print the contents of a page table</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"page table %p\n"</span>, pagetable);</span><br><span class="line">  helpervmprint(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  We can get the output like this. In the top-level page table ,we have two entry. The first entry corresponding 1GB address. In the bottom page table ,we have three entries  ,corresponding the <code>text and data</code> ,<code>guard page</code> and <code>stack</code>.  The second entry in top-level page table ,  corresponding the <code>trampoline</code> and <code>tramframe</code> . We have two interesting points.</p><ul><li>The reason about the <code>text and data</code> are mapped together not respectively only for simplicity.</li><li>The <code>trampoline</code>  and <code>tramframe</code> are mapped highest in va , but in page table ,they are in entry <code>255</code>,not in <code>511</code>,because  although the <code>riscv</code>  uses 39-bits,it actually uses 38 bits ( because  if we use the 39th bit ,the 40th 41th 42th ..etc should be set <strong>All for simplicity! But still support for the future!</strong>) , so in the top-level page table ,we only have 8 bits, the highest bit is <code>255</code>.</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line">..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line">.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line">.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line">.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line">.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line">..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line">.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line">.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000</span><br><span class="line">.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure></blockquote><p>We actually can print the <code>PTE_FLAG</code> for each valid pte.</p><h2 id="Part-2-A-kernel-page-table-per-process"><a href="#Part-2-A-kernel-page-table-per-process" class="headerlink" title="Part 2  A kernel page table per process"></a>Part 2  A kernel page table per process</h2><p>  The lab is vert time-consuming ,because we are doing kernel programming  which is difficult to track the bug  and easy to make error. The points we should pay attention to :</p><ul><li>The <code>xv6</code> code is specialized for  kernel page table </li><li>the kernel page table  init  <code>kvminit</code>  happens in <code>pricinit</code> and <code>virto_disc</code>.</li><li>the memory free-up</li></ul><p>In part 3 , we will add user mapping in process’s kernel page table  to allow the kernel to dereference  the user pointer. This scheme rely on the <strong>user virtual memory range not overlapping the range of the <code>va</code> that the kernel address uses for its own instructions and data .</strong><br>       Xv6 uses virtual addresses that start at zero for user address spaces, and luckily the kernel’s memory starts at higher addresses. <strong>However, this scheme does limit the maximum size of a user process to be less than the kernel’s lowest virtual address.</strong> After the kernel has booted, that address is 0xC000000 in xv6, the address of the <code>PLIC</code> registers .You’ll need to modify xv6 to prevent user processes from growing larger than the PLIC address.<br>        Through the calculating , the<code>kernel base</code> is in  entry 2 .And the <code>PLIC</code> is in entry zero ,anything above the <code>PLIC</code>.So any user mapping below the <code>PLIC</code> will be added into process’s kernel page table .And anything above that will be identical to the kernel page table.<br>         So the entry 1-511 we can share the same page table with the kernel page table . The entry zero should be unique in process’s kernel page table. This is called <code>share</code> solution.<br>        We could have the naive  <code>copy</code> solution , when we switch in  process , we copy the ,when we switch out ,we free up the page table .</p><h3 id="The-init-of-process-kernel-page-table"><a href="#The-init-of-process-kernel-page-table" class="headerlink" title="The init of process kernel page table"></a>The <code>init</code> of process kernel page table</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//share the 1-511 entry and map the entry zero  for process 's kernel page table init</span></span><br></pre></td></tr></table></figure><h3 id="The-clean-of-process-kernel-page-table"><a href="#The-clean-of-process-kernel-page-table" class="headerlink" title="The clean of process kernel page table"></a>The clean of process kernel page table</h3><p>When we free the  process’s kernel page table ,because entry 1-511 we share the same thing with the kernel page table ,so we do not need to free that memory . So we do free the lower level page table corresponding the entry zero. We can get <code>medium level</code> page table through the <code>pagetable[0]</code> ,  and free any valid pte  and corresponding <code>bottom level</code> page table .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>The course lab site</strong> :<a href="https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html">MIT 6.S081 pgtbl</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Pgtbl-Lab&quot;&gt;&lt;a href=&quot;#Pgtbl-Lab&quot; class=&quot;headerlink&quot; title=&quot;Pgtbl Lab&quot;&gt;&lt;/a&gt;Pgtbl Lab&lt;/h1&gt;&lt;p&gt;  In this lab , we will explore the user p</summary>
      
    
    
    
    <category term="6.S081" scheme="https://walkerzf.github.io/categories/6-S081/"/>
    
    
    <category term="Lab" scheme="https://walkerzf.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>Introduction</title>
    <link href="https://walkerzf.github.io/2020/10/21/hello-world/"/>
    <id>https://walkerzf.github.io/2020/10/21/hello-world/</id>
    <published>2020-10-21T15:27:17.565Z</published>
    <updated>2020-10-21T15:27:17.565Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to Zat’s Blog.My name is Zhou Fang.</p><h2 id="Education"><a href="#Education" class="headerlink" title="Education"></a>Education</h2><ul><li>2015/9~2019/6    |    BeiHang University    |    Electrical Engineering    |    Bachelor</li><li>2019/9~                |     ZheJiang University    |   Electrical Engineering     |   Master</li></ul><h2 id="Experience"><a href="#Experience" class="headerlink" title="Experience"></a>Experience</h2><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul><li>[Github][<a href="https://github.com/walkerzf]">https://github.com/walkerzf]</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to Zat’s Blog.My name is Zhou Fang.&lt;/p&gt;
&lt;h2 id=&quot;Education&quot;&gt;&lt;a href=&quot;#Education&quot; class=&quot;headerlink&quot; title=&quot;Education&quot;&gt;&lt;/a&gt;Educatio</summary>
      
    
    
    
    <category term="intro" scheme="https://walkerzf.github.io/categories/intro/"/>
    
    
    <category term="intro" scheme="https://walkerzf.github.io/tags/intro/"/>
    
  </entry>
  
</feed>
