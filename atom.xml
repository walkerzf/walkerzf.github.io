<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zat&#39;s Blog</title>
  
  <subtitle>Zat 的自留地</subtitle>
  <link href="https://walkerzf.github.io/atom.xml" rel="self"/>
  
  <link href="https://walkerzf.github.io/"/>
  <updated>2020-11-22T11:04:23.464Z</updated>
  <id>https://walkerzf.github.io/</id>
  
  <author>
    <name>Zhou Fang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>6.S081 mmap Lab</title>
    <link href="https://walkerzf.github.io/2020/11/22/mmap/"/>
    <id>https://walkerzf.github.io/2020/11/22/mmap/</id>
    <published>2020-11-22T15:10:00.000Z</published>
    <updated>2020-11-22T11:04:23.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mmap-Lab"><a href="#mmap-Lab" class="headerlink" title="mmap Lab"></a>mmap Lab</h1><p>The <code>mmap</code> and <code>munmap</code> system calls allow UNIX programs to exert detailed control over their address spaces. They can be used to share memory among processes, to map files into process address spaces,but this lab requires only a subset of its features relevant to memory-mapping a file</p><h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a><code>mmap</code></h1><p>Keep track of what <code>mmap</code> has mapped for each process. Define a structure corresponding to the VMA (virtual memory area) ,recording the address, length, permissions, file, etc. for a virtual memory range created by <code>mmap</code> .The VMA should contain a pointer to a <code>struct file</code> for the file being mapped; <code>mmap</code> should increase the file’s reference count so that the structure doesn’t disappear when the file is closed (hint: see <code>filedup</code>). </p><p><code>proc.h</code> : one more field.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> <span class="title">vma</span>[16];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMA</span>&#123;</span></span><br><span class="line">  uint64 addr;<span class="comment">// the start address of va </span></span><br><span class="line">  uint64 <span class="built_in">end</span>;<span class="comment">//the end address of va</span></span><br><span class="line">  <span class="keyword">int</span> prot;<span class="comment">// the prot permission</span></span><br><span class="line">  <span class="keyword">int</span> flags;<span class="comment">//map shared or privaet</span></span><br><span class="line">  <span class="keyword">int</span> fd;<span class="comment">//file descriptor</span></span><br><span class="line">  <span class="keyword">int</span> offset;<span class="comment">//the offset of the file  = 0</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">pf</span>;</span><span class="comment">// the pointer to the file struct</span></span><br><span class="line">  <span class="keyword">int</span> used;<span class="comment">//indicates this vma is used or not used</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sys_mmap</code> : </p><ul><li>get the system call argument value using the helper function ,<code>argfd</code> is very interesting</li><li>the file is not writable but using <code>prot  PROT_WRITE</code> and <code>MAP_SHARED</code> should be a failed <code>mmap</code></li><li>get a free <code>vma</code> field to store the value  , lazy increase the size of the user process , So we ensure that <code>mmap</code> of a large file is fast, and that <code>mmap</code> of a file larger than physical memory is possible.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_mmap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  <span class="comment">// void * addr  uint  length  int  prot  int  flags  int  fd  int  offset</span></span><br><span class="line">  <span class="comment">//addr will always be zero</span></span><br><span class="line">  <span class="comment">// offset will be zero</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="keyword">int</span> prot, flags, fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argfd(<span class="number">4</span>, &amp;fd, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">  <span class="comment">//not allocate the pa and not really read the file for read the large file fast and large file possible</span></span><br><span class="line">  <span class="comment">//find a a,ddress</span></span><br><span class="line">  <span class="keyword">if</span>(!f-&gt;writable&amp;&amp;(prot&amp;PROT_WRITE)&amp;&amp;flags == MAP_SHARED) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;originalsize == <span class="number">-1</span>)</span><br><span class="line">    p-&gt;originalsize = p-&gt;sz;</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; index &lt; <span class="number">16</span>; index++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[index].used == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, index);</span><br><span class="line">  <span class="keyword">if</span> (index != <span class="number">16</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    filedup(f);</span><br><span class="line">    <span class="comment">//find an empty but page -aligned</span></span><br><span class="line">    uint64 va = (p-&gt;sz);</span><br><span class="line">    p-&gt;sz = va + length;</span><br><span class="line">    <span class="comment">//create a new entry in struct</span></span><br><span class="line">    p-&gt;vma[index].addr = va;</span><br><span class="line">    p-&gt;vma[index].<span class="built_in">end</span> = PGROUNDUP(va + length);</span><br><span class="line">    p-&gt;vma[index].prot = prot;</span><br><span class="line">    p-&gt;vma[index].flags = flags;</span><br><span class="line">    <span class="comment">//p-&gt;vma[index].fd = fd;</span></span><br><span class="line">    p-&gt;vma[index].offset = <span class="number">0</span>;</span><br><span class="line">    p-&gt;vma[index].pf = f;</span><br><span class="line"></span><br><span class="line">    p-&gt;vma[index].used = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> va;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a><code>usertrap</code></h1><p>The page  fault handler in <code>trap.c</code>. The structure is similar to the <code>cowfault</code>!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">15</span> || r_scause() == <span class="number">13</span>)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (helper(p-&gt;pagetable, r_stval()) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>The <code>va</code> is no valid should kill the process</li><li>Or we need to find the corresponding  <code>vma</code>  to know the start address address and the end address and <code>prot</code> (the name of variable makes sense plz! It makes me spend more three hours ,using <code>gdb</code> to debug plz!)</li><li>read the file content and add mapping in <code>helper</code> function .The offset of the file depends on the <code>va</code> and the start of the mapping because the offset = 0  .The mapping always be <code>PGSIZE</code>.</li><li><code>readi</code> needs the lock the <code>inode</code> of the file </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  <span class="keyword">if</span> (va &gt; MAXVA || va &gt;= p-&gt;sz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; index &lt; <span class="number">16</span>; index++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//printf("%d\n",p-&gt;vma[index].used);</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[index].used == <span class="number">1</span> &amp;&amp; va &gt;= p-&gt;vma[index].addr &amp;&amp; va &lt; p-&gt;vma[index].<span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  !!!!!! the name of variable make sense plz!!!!</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//printf("%d!\n", index);</span></span><br><span class="line">  <span class="keyword">if</span> (index == <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//get the index</span></span><br><span class="line">  uint64 addr = p-&gt;vma[index].addr;</span><br><span class="line">  <span class="comment">//int length = p-&gt;vma[index].length;</span></span><br><span class="line">  <span class="comment">//int prot = p-&gt;vma[index].prot;</span></span><br><span class="line">  <span class="keyword">int</span> prot = p-&gt;vma[index].prot;</span><br><span class="line">  <span class="comment">//int fd = p-&gt;vma[index].fd;</span></span><br><span class="line">  <span class="comment">//int offset = p-&gt;vma[index].offset;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">pf</span> = <span class="title">p</span>-&gt;<span class="title">vma</span>[<span class="title">index</span>].<span class="title">pf</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//allocate the pa and map</span></span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  mem = (<span class="keyword">char</span> *)kalloc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//read the file date into the pa</span></span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  begin_op();</span><br><span class="line">  ilock(pf-&gt;ip);</span><br><span class="line">  <span class="keyword">if</span> (readi(pf-&gt;ip, <span class="number">0</span>, (uint64)mem, va - addr, PGSIZE) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    iunlock(pf-&gt;ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlock(pf-&gt;ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="comment">//printf("%s\n",mem[0]);</span></span><br><span class="line">  uint64 f = PTE_U;</span><br><span class="line">  <span class="keyword">if</span> (prot &amp; PROT_EXEC)</span><br><span class="line">    f |= PTE_X;</span><br><span class="line">  <span class="keyword">if</span> (prot &amp; PROT_READ)</span><br><span class="line">    f |= PTE_R;</span><br><span class="line">  <span class="keyword">if</span> (prot &amp; PROT_WRITE)</span><br><span class="line">    f |= PTE_W;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, va, PGSIZE, (uint64)mem, f) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unmmap"><a href="#unmmap" class="headerlink" title="unmmap"></a><code>unmmap</code></h1><p>We need tot  find the VMA for the address range and <code>unmap</code> the specified pages  using  <code>uvmunmap</code>. Our own <code>unmmap</code> only writes back the file is mapped <code>MAP_SHARED</code> .Because the test does  not check that not dirty bit are not written back; thus you can get away with writing pages back without looking at <code>D</code> bits. </p><p>In the test , we only <code>unmmap</code> the part in the beginning of the file or at the end of the file. So we do not need to dup a new <code>vma</code> for the <code>unmmap</code>. </p><ul><li>according to the address , we find the <code>vma</code> </li><li>check the bit of the <code>flags</code> of map , to decide whether write back or not <ul><li>write back using <code>writei</code> , writing to the suitable offset of the file </li></ul></li><li>using <code>unmunmap</code> to help <code>unmap</code> the mapping in the page table</li><li>do some change to the <code>vma</code>  , if the whole region of file is unmapped , we decrease the <code>refcnt</code> of the file using the helper function in <code>file.c</code></li><li>Modify <code>fork</code> to ensure that the child has the same mapped regions as the parent. Don’t forget to increment the reference count for a VMA’s <code>struct file</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_munmap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; index &lt; <span class="number">16</span>; index++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[index].used == <span class="number">1</span> &amp;&amp; p-&gt;vma[index].addr &lt;= addr </span><br><span class="line">        &amp;&amp;addr&lt;p-&gt;vma[index].<span class="built_in">end</span>)</span><br><span class="line">    &#123; </span><br><span class="line">      <span class="comment">//according to the test case to code  </span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;vma[index].flags==MAP_SHARED)&#123;</span><br><span class="line">        begin_op();</span><br><span class="line">        ilock(p-&gt;vma[index].pf-&gt;ip);</span><br><span class="line">        writei(p-&gt;vma[index].pf-&gt;ip,<span class="number">1</span>,addr,addr - p-&gt;vma[index].addr,len);</span><br><span class="line">        iunlock(p-&gt;vma[index].pf-&gt;ip);</span><br><span class="line">        end_op();</span><br><span class="line">      &#125;</span><br><span class="line">      uvmunmap(p-&gt;pagetable,addr,len/PGSIZE,<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//in the former part</span></span><br><span class="line">      <span class="comment">//not in the middle part</span></span><br><span class="line">      <span class="keyword">if</span>(addr==p-&gt;vma[index].addr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;vma[index].<span class="built_in">end</span>==addr+len)&#123;</span><br><span class="line">          <span class="comment">//decrease the filecnt</span></span><br><span class="line">          fileddown(p-&gt;vma[index].pf);</span><br><span class="line">          p-&gt;vma[index].used = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;vma[index].addr = addr+len;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>( addr+len == p-&gt;vma[index].<span class="built_in">end</span>)&#123;</span><br><span class="line">        p-&gt;vma[index].<span class="built_in">end</span> = addr+len;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//the sub of one mmap</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fork</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">    np-&gt;vma[i].addr = p-&gt;vma[i].addr;</span><br><span class="line">    np-&gt;vma[i].<span class="built_in">end</span> = p-&gt;vma[i].<span class="built_in">end</span>;</span><br><span class="line">    np-&gt;vma[i].prot = p-&gt;vma[i].prot;</span><br><span class="line">    np-&gt;vma[i].flags = p-&gt;vma[i].flags;</span><br><span class="line">    np-&gt;vma[i].used = p-&gt;vma[i].used;</span><br><span class="line">    <span class="keyword">if</span>((np-&gt;vma[i].pf = p-&gt;vma[i].pf)!=<span class="number">0</span>)&#123;</span><br><span class="line">      filedup(np-&gt;vma[i].pf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//and in the `uvmcopy`</span></span><br><span class="line"><span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic("uvmcopy: pte should exist");</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic("uvmcopy: page not present");</span></span><br></pre></td></tr></table></figure><p><code>filedown</code> similar to <code>filedup</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decrease ref count for file f.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>*</span></span><br><span class="line"><span class="class"><span class="title">fileddown</span>(<span class="title">struct</span> <span class="title">file</span> *<span class="title">f</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"fileddown"</span>);</span><br><span class="line">  f-&gt;ref--;</span><br><span class="line">  <span class="built_in">release</span>(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><p><a href="https://pdos.csail.mit.edu/6.828/2020/labs/mmap.html">Link to mmap  Lab Page</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mmap-Lab&quot;&gt;&lt;a href=&quot;#mmap-Lab&quot; class=&quot;headerlink&quot; title=&quot;mmap Lab&quot;&gt;&lt;/a&gt;mmap Lab&lt;/h1&gt;&lt;p&gt;The &lt;code&gt;mmap&lt;/code&gt; and &lt;code&gt;munmap&lt;/code&gt; </summary>
      
    
    
    
    <category term="6.S081" scheme="https://walkerzf.github.io/categories/6-S081/"/>
    
    
    <category term="Lab" scheme="https://walkerzf.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 FS Lab</title>
    <link href="https://walkerzf.github.io/2020/11/20/FSLab/"/>
    <id>https://walkerzf.github.io/2020/11/20/FSLab/</id>
    <published>2020-11-20T03:10:00.000Z</published>
    <updated>2020-11-22T11:04:23.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FS-Lab"><a href="#FS-Lab" class="headerlink" title="FS Lab"></a>FS Lab</h1><p>In this lab you will add large files and symbolic links to the xv6 file system.</p><p>In the first part ,  you will make the max size of a file in <code>xv6</code> much bigger through sacrifice a direct block and adding a doubly-indirect block. In the second part , you will add symbolic link to the file in <code>xv6</code> .Symbolic links resembles hard links, but hard links are restricted to pointing to file on the same disk, while symbolic links can cross disk devices. This is a good exercise to know about the pathname lookup in xv6</p><h1 id="Part-1-Large-files"><a href="#Part-1-Large-files" class="headerlink" title="Part 1 Large files"></a>Part 1 Large files</h1><p>The first 11 elements of <code>ip-&gt;addrs[]</code> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when <code>bigfile</code> writes 65803 blocks .</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDIRECT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  <span class="comment">//...//</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>bmap</code> function need to handle the doubly-indirect block</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> uint</span><br><span class="line">bmap(struct inode *ip, uint bn)</span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bn &lt; NDIRECT)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bn &lt; NINDIRECT)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Load singly-indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint *)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> ((addr = a[bn]) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Load doubly-indirect block, allocating if necessary.</span></span><br><span class="line">    bn -= NINDIRECT;</span><br><span class="line">    <span class="comment">//allocate</span></span><br><span class="line">    <span class="keyword">if</span> ((addr = ip-&gt;addrs[DDIRECT]) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ip-&gt;addrs[DDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    &#125;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint *)bp-&gt;data;</span><br><span class="line">     <span class="comment">//doubly-indirect block ,we need to allocate on the block </span></span><br><span class="line">    <span class="keyword">int</span> index = bn / NINDIRECT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((addr = a[i]) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        a[i] = addr = balloc(ip-&gt;dev);</span><br><span class="line">        <span class="comment">//log write must be in the loop </span></span><br><span class="line">        <span class="comment">//because when we read we have not the fs syscall</span></span><br><span class="line">        log_write(bp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    brelse(bp);</span><br><span class="line">     <span class="comment">//read the exacyly indirect block , and allocate a block and write </span></span><br><span class="line">    bn -= NINDIRECT * index;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint *)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> ((addr = a[bn]) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  panic(<span class="string">"bmap: out of range"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Make sure that <code>struct inode</code> and <code>struct dinode</code> have the same number of elements in their <code>addrs[]</code> arrays. We need  to fix the <code>struct dinode</code>  in the same way.</p><p><code>itrunc</code>  function need to erase the content on the all block belonging to the <code>inode</code> or <code>file</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">itrunc</span><span class="params">(struct inode *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NDIRECT; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;addrs[i])</span><br><span class="line">    &#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;addrs[NDIRECT])</span><br><span class="line">  &#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint *)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NINDIRECT; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;addrs[DDIRECT])</span><br><span class="line">  &#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[DDIRECT]);</span><br><span class="line">    a = (uint *)bp-&gt;data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">    uint * ba;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NINDIRECT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i])</span><br><span class="line">      &#123;</span><br><span class="line">        b = bread(ip-&gt;dev, a[i]);</span><br><span class="line">        ba = (uint *)b-&gt;data;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(ba[j]) bfree(ip-&gt;dev,ba[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(b);</span><br><span class="line">        bfree(ip-&gt;dev,a[i]);</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[DDIRECT]);</span><br><span class="line">    ip-&gt;addrs[DDIRECT] = <span class="number">0</span>;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Part-2-Symbolic-links"><a href="#Part-2-Symbolic-links" class="headerlink" title="Part 2  Symbolic links"></a>Part 2  Symbolic links</h1><p>In this part of lab , we need to add a system call into <code>xv6</code> , which is <code>symbolic links</code> i.e. <code>soft link</code> . </p><p>The <code>symbolic links</code> wants we to creates a new <code>file</code> which type is still <code>FD_INODE</code>, but the  <code>inode&#39;s</code> type is  <code>T_SYMBOLIC</code> ,  so we in the system call we need to allocate a new <code>inode</code> ,and allocate a new block for the first <code>direct block</code> .and write the length of the path and the path string in the block. Because the size of the length must a four-byte variable ,which is convenient for the <code>read</code> data from the block.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// labfs symbolic system call</span></span><br><span class="line">uint64</span><br><span class="line">sys_symlink(<span class="keyword">void</span>)</span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">char</span>  target[MAXPATH], path[MAXPATH];</span><br><span class="line"> <span class="comment">// struct inode *dp;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="comment">//struct buf * b;</span></span><br><span class="line">  <span class="comment">//char * c;</span></span><br><span class="line">  <span class="keyword">if</span> (argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">//create will have the lock for the inode ip</span></span><br><span class="line">  <span class="keyword">if</span>((ip =  create(path,T_SYMLINK,<span class="number">0</span>,<span class="number">0</span>))==<span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(target);</span><br><span class="line">  writei(ip,<span class="number">0</span>,(uint64)&amp;len,<span class="number">0</span>,<span class="keyword">sizeof</span>(len));</span><br><span class="line">  writei(ip,<span class="number">0</span>,(uint64)target,<span class="keyword">sizeof</span>(len),len+<span class="number">1</span>);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In  <code>sys_open</code> system call , we need to fix the  function to handle the <code>inode&#39;s</code> type is <code>T_SYMBOLIC</code>. And we should  return false when we in a circle!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>,len ;</span><br><span class="line">  <span class="keyword">char</span> next[MAXPATH+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(!(omode&amp;O_NOFOLLOW))&#123;</span><br><span class="line">    <span class="keyword">for</span>( ; depth&lt;<span class="number">10</span> &amp;&amp; ip-&gt;type ==T_SYMLINK ;depth++)&#123;</span><br><span class="line">      readi(ip,<span class="number">0</span>,(uint64)&amp;len,<span class="number">0</span>,<span class="keyword">sizeof</span>(len));</span><br><span class="line">      readi(ip,<span class="number">0</span>,(uint64)next,<span class="keyword">sizeof</span>(len),len);</span><br><span class="line">      next[len]= <span class="number">0</span>;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">if</span>((ip=namei(next))==<span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ilock(ip);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(depth&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><p><a href="https://pdos.csail.mit.edu/6.828/2020/labs/fs.html">Link to Lab Page</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FS-Lab&quot;&gt;&lt;a href=&quot;#FS-Lab&quot; class=&quot;headerlink&quot; title=&quot;FS Lab&quot;&gt;&lt;/a&gt;FS Lab&lt;/h1&gt;&lt;p&gt;In this lab you will add large files and symbolic link</summary>
      
    
    
    
    <category term="6.S081" scheme="https://walkerzf.github.io/categories/6-S081/"/>
    
    
    <category term="Lab" scheme="https://walkerzf.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lock Lab</title>
    <link href="https://walkerzf.github.io/2020/11/19/Lock/"/>
    <id>https://walkerzf.github.io/2020/11/19/Lock/</id>
    <published>2020-11-19T07:20:00.000Z</published>
    <updated>2020-11-22T11:04:23.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lock-Lab"><a href="#Lock-Lab" class="headerlink" title="Lock Lab"></a>Lock Lab</h1><p>In this lab you’ll gain experience in re-designing code to increase parallelism. A common symptom of poor parallelism on multi-core machines is high lock contention. Improving parallelism often involves changing both data structures and locking strategies in order to reduce contention. You’ll do this for the xv6 memory allocator and block cache.</p><h1 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h1><p>It is straightforward to  assign each lock to each CPU ‘s  <code>freelist</code>.</p><ul><li>The basic idea is to maintain a free list per CPU, each list with its own lock.</li></ul><ul><li>Let <code>freerange</code> give all free memory to the CPU running <code>freerange</code>.</li><li>The function <code>cpuid</code> returns the current core number, but it’s only safe to call it and use its result when interrupts are turned off. You should use <code>push_off()</code> and <code>pop_off()</code> to turn interrupts off and on.</li></ul><p>Redesign struct<code>kmem[NCPU]</code> .</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU];</span><br></pre></td></tr></table></figure><p>Assign all free page to the CPU which calls the <code>freerange</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> id = cpuid();</span><br><span class="line">  acquire(&amp;kmem[id].lock);</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  p = (<span class="keyword">char</span> *)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span> (; p + PGSIZE &lt;= (<span class="keyword">char</span> *)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">1</span>, PGSIZE);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> = (<span class="title">struct</span> <span class="title">run</span> *)<span class="title">p</span>;</span></span><br><span class="line">    </span><br><span class="line">    r-&gt;next = kmem[id].freelist;</span><br><span class="line">    kmem[id].freelist = r;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem[id].lock);</span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Kfree</code> and <code>Kalloc</code> will relate to the which CPU calls the function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span> *)pa &lt; <span class="built_in">end</span> || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">"kfree"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct <span class="built_in">run</span> *)pa;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> id = cpuid();</span><br><span class="line">  acquire(&amp;kmem[id].lock);</span><br><span class="line">  r-&gt;next = kmem[id].freelist;</span><br><span class="line">  kmem[id].freelist = r;</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem[id].lock);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">kalloc(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> id = cpuid();</span><br><span class="line">  acquire(&amp;kmem[id].lock);</span><br><span class="line"></span><br><span class="line">  r = kmem[id].freelist;</span><br><span class="line">  <span class="keyword">if</span> (r)</span><br><span class="line">    kmem[id].freelist = r-&gt;next;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == id)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      acquire(&amp;kmem[i].lock);</span><br><span class="line">      r = kmem[i].freelist;</span><br><span class="line">      <span class="keyword">if</span> (r)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//remember to release</span></span><br><span class="line">        kmem[i].freelist = r-&gt;next;</span><br><span class="line">        <span class="built_in">release</span>(&amp;kmem[i].lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//remember to release</span></span><br><span class="line">        <span class="built_in">release</span>(&amp;kmem[i].lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem[id].lock);</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">if</span> (r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h1><p>This is similar to the <code>Memory allocator</code> , but we can not assign a bucket for each CPU , because these buffers are shared among each CPU or each Process.</p><p>According to the hint , we remove the doubly-linked list , add two filed <code>used</code> (means the buffer is inuse or free) and <code>timestamp</code> to recycle a buffer.</p><p><code>Struct BUF</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="keyword">int</span> disk;    <span class="comment">// does disk "own" buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">  <span class="keyword">int</span> used;</span><br><span class="line">  uint timestamp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>bcache</code> Bucket . <code>helper lock</code> helps the  serialize eviction in <code>Bget</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define NBUCKET 13</span><br><span class="line">struct spinlock helperlock;</span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct buf buf[NBUF];</span><br><span class="line">&#125; bcache[NBUCKET];</span><br></pre></td></tr></table></figure><p><code>Bget</code>  function </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct buf *<span class="title">bget</span><span class="params">(uint dev, uint blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;helperlock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="keyword">int</span> id = blockno % NBUCKET;</span><br><span class="line">  acquire(&amp;bcache[id].lock);</span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NBUF; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    b = &amp;bcache[id].buf[i];</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno &amp;&amp; b-&gt;used)</span><br><span class="line">    &#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      b-&gt;timestamp = ticks;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache[id].lock);</span><br><span class="line">      <span class="comment">// pop_off();</span></span><br><span class="line">      <span class="built_in">release</span>(&amp;helperlock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">//what we need to do is to find a buffer index in index bucket</span></span><br><span class="line">  <span class="comment">//and recycle one buf whose timestamp is samllest and refcnt == 0 and active.!</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dst</span> = 0, *<span class="title">src</span> = 0;</span></span><br><span class="line">  uint time = <span class="number">0x7fffffff</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NBUF; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (bcache[id].buf[i].used == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      dst = &amp;bcache[id].buf[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//search a smallest timestamp</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != id)</span><br><span class="line">    &#123;</span><br><span class="line">      acquire(&amp;bcache[i].lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NBUF; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      b = &amp;bcache[i].buf[j];</span><br><span class="line">      <span class="keyword">if</span> (b-&gt;used == <span class="number">1</span> &amp;&amp; b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt; time)</span><br><span class="line">      &#123;</span><br><span class="line">        time = b-&gt;timestamp;</span><br><span class="line">        src = b;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (pre == <span class="number">-1</span>)</span><br><span class="line">        pre = i;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre != id)</span><br><span class="line">          <span class="built_in">release</span>(&amp;bcache[pre].lock);</span><br><span class="line">        pre = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i != id)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache[i].lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (src == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"No buffer!\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//get the dst and src</span></span><br><span class="line">  <span class="comment">//implement  replace</span></span><br><span class="line">  <span class="keyword">if</span> (dst == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    dst = src;</span><br><span class="line">  &#125;</span><br><span class="line">  src-&gt;used = <span class="number">0</span>;</span><br><span class="line">  dst-&gt;used = <span class="number">1</span>;</span><br><span class="line">  dst-&gt;dev = dev;</span><br><span class="line">  dst-&gt;blockno = blockno;</span><br><span class="line">  dst-&gt;used = <span class="number">1</span>;</span><br><span class="line">  dst-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  dst-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache[id].lock);</span><br><span class="line">  <span class="keyword">if</span>(pre!=id) <span class="built_in">release</span>(&amp;bcache[pre].lock);</span><br><span class="line">  <span class="built_in">release</span>(&amp;helperlock);</span><br><span class="line">  acquiresleep(&amp;dst-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>brelse</code> <code>bpin</code> <code>bunpin</code> function</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findbucket</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= bcache[i].buf &amp;&amp; b &lt;= (bcache[i].buf + NBUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">"findbucket"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="comment">// we have the structure in the bucket , no need to move the buffer!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brelse</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">"brelse"</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line">  <span class="keyword">int</span> id = findbucket(b);</span><br><span class="line">  acquire(&amp;bcache[id].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache[id].lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bpin</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = findbucket(b);</span><br><span class="line">  acquire(&amp;bcache[id].lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache[id].lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bunpin</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = findbucket(b);</span><br><span class="line">  acquire(&amp;bcache[id].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache[id].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><p><a href="https://pdos.csail.mit.edu/6.828/2020/labs/lock.html">Link to Lock Lab Page</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lock-Lab&quot;&gt;&lt;a href=&quot;#Lock-Lab&quot; class=&quot;headerlink&quot; title=&quot;Lock Lab&quot;&gt;&lt;/a&gt;Lock Lab&lt;/h1&gt;&lt;p&gt;In this lab you’ll gain experience in re-desig</summary>
      
    
    
    
    <category term="6.S081" scheme="https://walkerzf.github.io/categories/6-S081/"/>
    
    
    <category term="Lab" scheme="https://walkerzf.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Multithreading Lab</title>
    <link href="https://walkerzf.github.io/2020/11/17/Multithreading/"/>
    <id>https://walkerzf.github.io/2020/11/17/Multithreading/</id>
    <published>2020-11-17T06:10:00.000Z</published>
    <updated>2020-11-22T11:04:23.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MultithreadingLab"><a href="#MultithreadingLab" class="headerlink" title="MultithreadingLab"></a>MultithreadingLab</h1><p>his lab will familiarize you with multithreading. You will implement switching between threads in a user-level threads package, use multiple threads to speed up a program, and implement a barrier.</p><h1 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h1><p>The <code>Thread 0</code> is the main function , which will not be scheduled again after scheduled out .</p><p>Similar to the <code>sched</code> and <code>schedule</code> function , in <code>uthread.c</code> ,the <code>ra</code> and <code>sp</code>  and  other registers will be store  and restore other thread’s registers in <code>thread_schedule</code>  function (which is coded by asm ),so once the creation of the thread , the <code>ra</code> will  be corresponding function , <code>sp</code> will the <strong>top</strong> of their own  <code>stack</code> .</p><p>Once every thread is created, <code>thread_schedule</code>, the three thread will continue to switching!</p><p>In <code>thread_schedule</code> ,store and restore!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">thread_switch:</span><br><span class="line">&#x2F;* YOUR CODE HERE *&#x2F;</span><br><span class="line"> sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        sd s2, 32(a0)</span><br><span class="line">        sd s3, 40(a0)</span><br><span class="line">        sd s4, 48(a0)</span><br><span class="line">        sd s5, 56(a0)</span><br><span class="line">        sd s6, 64(a0)</span><br><span class="line">        sd s7, 72(a0)</span><br><span class="line">        sd s8, 80(a0)</span><br><span class="line">        sd s9, 88(a0)</span><br><span class="line">        sd s10, 96(a0)</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        ld s2, 32(a1)</span><br><span class="line">        ld s3, 40(a1)</span><br><span class="line">        ld s4, 48(a1)</span><br><span class="line">        ld s5, 56(a1)</span><br><span class="line">        ld s6, 64(a1)</span><br><span class="line">        ld s7, 72(a1)</span><br><span class="line">        ld s8, 80(a1)</span><br><span class="line">        ld s9, 88(a1)</span><br><span class="line">        ld s10, 96(a1)</span><br><span class="line">        ld s11, 104(a1)</span><br><span class="line">ret    &#x2F;* return to ra *&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_switch((uint64)t,(uint64)current_thread);</span><br></pre></td></tr></table></figure><p>Creation of thread</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">thread_create(<span class="keyword">void</span> (*func)())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  t-&gt;ra = (uint64)func;</span><br><span class="line">  t-&gt;sp = (uint64)(t-&gt;<span class="built_in">stack</span>+STACK_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is different from the thread switching in the kernel . In this case ,we  switch between different threads directly. In kernel , we switch to the CPU’s schedule  thread ,and pick a thread to switch to.</p><h1 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h1><p>We will create a lock for each bucket!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock[NBUCKET]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">table</span>[<span class="title">NBUCKET</span>];</span></span><br></pre></td></tr></table></figure><p>For concurrent <code>put</code> , we need to acquire lock for each bucket!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = key % NBUCKET;</span><br><span class="line">  pthread_mutex_lock(&amp;lock[i]); </span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> = 0;</span></span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125; </span><br><span class="line">  pthread_mutex_unlock(&amp;lock[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Barriers"><a href="#Barriers" class="headerlink" title="Barriers"></a>Barriers</h1><p>We need all threads reach the <code>barrier</code> , we go the next stage. So we need to sleep a thread when it reaches. When all threads reach the <code>barrier</code> , clear the <code>cnt</code> 、 increase the <code>round</code> and <code>wakeup</code> other sleep thread!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">barrier()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread==nthread)&#123;</span><br><span class="line">      bstate.round++;</span><br><span class="line">      bstate.nthread = <span class="number">0</span>;</span><br><span class="line">      pthread_cond_broadcast(&amp;bstate.barrier_cond); </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><p><a href="https://pdos.csail.mit.edu/6.828/2020/labs/thread.html">Thread Lab</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MultithreadingLab&quot;&gt;&lt;a href=&quot;#MultithreadingLab&quot; class=&quot;headerlink&quot; title=&quot;MultithreadingLab&quot;&gt;&lt;/a&gt;MultithreadingLab&lt;/h1&gt;&lt;p&gt;his lab wi</summary>
      
    
    
    
    <category term="6.S081" scheme="https://walkerzf.github.io/categories/6-S081/"/>
    
    
    <category term="Lab" scheme="https://walkerzf.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Cow Lab</title>
    <link href="https://walkerzf.github.io/2020/11/16/CowLab/"/>
    <id>https://walkerzf.github.io/2020/11/16/CowLab/</id>
    <published>2020-11-16T07:20:14.000Z</published>
    <updated>2020-11-22T11:04:23.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cow-Lab"><a href="#Cow-Lab" class="headerlink" title="Cow Lab"></a>Cow Lab</h1><p>Virtual memory provides a level of indirection: the kernel can intercept memory references by marking PTEs invalid or read-only, leading to <strong>page faults</strong>， and can change what addresses mean by modifying PTEs. There is a saying in computer systems that any systems problem can be solved with a level of indirection. <strong>The lazy allocation lab provided one example which is talked about in  the last lab</strong>. This lab explores another example: copy-on write fork.</p><h1 id="Fork’s-Problem"><a href="#Fork’s-Problem" class="headerlink" title="Fork’s Problem"></a>Fork’s Problem</h1><p>The fork() system call in xv6 copies all of the parent process’s user-space memory into the child. If the parent is large, copying can take a long time. Worse, the work is often largely wasted; for example, a fork() followed by exec() in the child will cause the child to discard the copied memory, probably without ever using most of it. On the other hand, if both parent and child use a page, and one or both writes it, a copy is truly needed.</p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>The goal of copy-on-write (COW) fork() is to defer allocating and copying physical memory pages for the child until the copies are actually needed, if ever.</p><p><code>Cow</code> fork will creates just a page table for the child , with PTEs for user memory pointing to the parent’s  <code>pa</code>. <code>Cow</code> fork will marks all the user PTEs in both parent and child as not writable. When either process wants to write any of these unwritable pages, will triggle a page fault .The kernel trap will handle this fault , allocates a page of physical memory for the page fault,copies the original page into the new page, and <strong>modifies the relevant PTE in the faulting process to refer to the new page</strong>, this time with the PTE marked writeable. The original pa will be not changed.</p><p><code>uvmcopy</code> we will not allocate new pages , we increase the <code>refcnt</code>  for the pa.</p><h2 id="Uvmcopy-not-allocate-the-new-pa"><a href="#Uvmcopy-not-allocate-the-new-pa" class="headerlink" title="Uvmcopy not allocate the new pa"></a><code>Uvmcopy</code> not allocate the new pa</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"uvmcopy: pte should exist"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"uvmcopy: page not present"</span>);</span><br><span class="line">    <span class="comment">//fix the permission bits</span></span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    *pte &amp;= ~PTE_W;</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"><span class="comment">//not allocated</span></span><br><span class="line">    <span class="comment">// if((mem = kalloc()) == 0)</span></span><br><span class="line">    <span class="comment">//   goto err;</span></span><br><span class="line">    <span class="comment">// memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line"><span class="comment">//increase refcnt</span></span><br><span class="line">    increse(pa);</span><br><span class="line">    <span class="comment">//map the va to the same pa using flags</span></span><br><span class="line">    <span class="keyword">if</span> (mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kalloc-Kfree-increase-cnt"><a href="#Kalloc-Kfree-increase-cnt" class="headerlink" title="Kalloc Kfree increase cnt"></a><code>Kalloc</code> <code>Kfree</code> <code>increase cnt</code></h2><p><code>kalloc</code> , we maintain the <code>refcnt</code> for every physical page .In the initialization , the <code>refcnt</code> will be <code>writed</code>to 1,because  in the <code>freerange</code> ,we call <code>kfree</code> which decreases the <code>refcnt</code> for every <code>pa</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> refcnt[PHYSTOP / PGSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  p = (<span class="keyword">char</span> *)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span> (; p + PGSIZE &lt;= (<span class="keyword">char</span> *)pa_end; p += PGSIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    refcnt[(uint64)p / PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>increase refcnt</code> and <code>kfree</code> is a combination , which is increase the <code>refcnt</code> of the <code>pa</code> , the other is decrease the <code>refcnt</code> of the pa .In the case when the <code>refcnt</code> of the <code>pa</code> down to zero , we really free the <code>pa</code>!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse</span><span class="params">(uint64 pa)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//acquire the lock</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">int</span> pn = pa / PGSIZE;</span><br><span class="line">  <span class="keyword">if</span>(pa&gt;PHYSTOP || refcnt[pn]&lt;<span class="number">1</span>)&#123;</span><br><span class="line">    panic(<span class="string">"increase ref cnt"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  refcnt[pn]++;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  r = (struct <span class="built_in">run</span> *)pa;</span><br><span class="line">  <span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span> *)pa &lt; <span class="built_in">end</span> || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">"kfree"</span>);</span><br><span class="line"><span class="comment">//when we free the page decraese the refcnt of the pa </span></span><br><span class="line">    <span class="comment">//we need to acquire the lock</span></span><br><span class="line">    <span class="comment">//and get the really current cnt for the current fucntion</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">int</span> pn = (uint64)r / PGSIZE;</span><br><span class="line">  <span class="keyword">if</span> (refcnt[pn] &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"kfree panic"</span>);</span><br><span class="line">  refcnt[pn] -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> tmp = refcnt[pn];</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tmp &gt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kalloc</code> function will allocate a <code>pa</code> ,  if the <code>pa</code> ref cnt is not valid , <code>panic</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">kalloc(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> pn = (uint64)r / PGSIZE;</span><br><span class="line">    <span class="keyword">if</span>(refcnt[pn]!=<span class="number">0</span>)&#123;</span><br><span class="line">      panic(<span class="string">"refcnt kalloc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    refcnt[pn] = <span class="number">1</span>;</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Handle-function-in-Trap"><a href="#Handle-function-in-Trap" class="headerlink" title="Handle function in Trap"></a>Handle function in Trap</h2><p>The <code>r_scause</code> of page fault is 15 or 13. In <code>usertrap</code> , we have <code>cowfault</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r_scause() == <span class="number">15</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span> ((cowfault(p-&gt;pagetable, r_stval()) )&lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong><code>cowfault</code> function</strong></p><ul><li>handle the  invalid <code>va</code> <ul><li>more than <code>MAXVA</code></li><li>not in the page table</li><li>not set user bit or valid bit</li></ul></li><li>allocate a new <code>pa</code> , copy the original content to the new <code>pa</code> ,  <ul><li><code>unmap</code> and  <code>map</code> for this <code>pte</code> entry!</li><li>or we cook up  the <code>pte</code>straightly</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cowfault</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_U) == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  uint64 pa1 = PTE2PA(*pte);</span><br><span class="line">  uint64 pa2 = (uint64)kalloc();</span><br><span class="line">  <span class="keyword">if</span> (pa2 == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//panic("cow panic kalloc");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  memmove((<span class="keyword">void</span> *)pa2, (<span class="keyword">void</span> *)pa1, PGSIZE);</span><br><span class="line">  *pte = PA2PTE(pa2) | PTE_U | PTE_V | PTE_W | PTE_X|PTE_R;</span><br><span class="line">   kfree((<span class="keyword">void</span> *)pa1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>One more thing ,according to the hint :  Modify <code>copyout()</code> to use the same scheme as page faults when it encounters a COW page.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">va0 = PGROUNDDOWN(dstva);</span><br><span class="line"><span class="keyword">if</span> (va0 &gt; MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line"><span class="keyword">if</span>(cowfault(pagetable,va0)&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.<strong>The course lab site</strong> :<a href="https://pdos.csail.mit.edu/6.828/2020/labs/cow.html">MIT 6.S081 cow Lab</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Cow-Lab&quot;&gt;&lt;a href=&quot;#Cow-Lab&quot; class=&quot;headerlink&quot; title=&quot;Cow Lab&quot;&gt;&lt;/a&gt;Cow Lab&lt;/h1&gt;&lt;p&gt;Virtual memory provides a level of indirection: th</summary>
      
    
    
    
    <category term="6.S081" scheme="https://walkerzf.github.io/categories/6-S081/"/>
    
    
    <category term="Lab" scheme="https://walkerzf.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lazy Lab</title>
    <link href="https://walkerzf.github.io/2020/11/13/LazyLab/"/>
    <id>https://walkerzf.github.io/2020/11/13/LazyLab/</id>
    <published>2020-11-13T12:10:14.000Z</published>
    <updated>2020-11-22T11:04:23.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lazy-Lab"><a href="#Lazy-Lab" class="headerlink" title="Lazy Lab"></a>Lazy Lab</h1><blockquote><p>One of the many neat tricks an O/S can play with page table hardware is lazy allocation of user-space heap memory. Xv6 applications ask the kernel for heap memory using the sbrk() system call. In the kernel we’ve given you, sbrk() allocates physical memory and maps it into the process’s virtual address space. It can take a long time for a kernel to allocate and map memory for a large request. Consider, for example, that a gigabyte consists of 262,144 4096-byte pages; that’s a huge number of allocations even if each is individually cheap. In addition, some programs allocate more memory than they actually use (e.g., to implement sparse arrays), or allocate memory well in advance of use. To allow sbrk() to complete more quickly in these cases, sophisticated kernels allocate user memory lazily. That is, sbrk() doesn’t allocate physical memory, but just remembers which user addresses are allocated and marks those addresses as invalid in the user page table. When the process first tries to use any given page of lazily-allocated memory, the CPU generates a page fault, which the kernel handles by allocating physical memory, zeroing it, and mapping it. You’ll add this lazy allocation feature to xv6 in this lab.</p></blockquote><h1 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h1><ul><li>for the system call <code>sbrl</code> <ul><li>the positive argument , we simply increase the size of the process ,which means grows the address space ,but mark the addresses not valid in the page table , </li><li>the negative argument , we directly  use the function <code>growproc</code>  ,which actually calls <code>uvmunmap</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sbrk(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(myproc()-&gt;originalsz==<span class="number">-1</span>)&#123;</span><br><span class="line">    myproc()-&gt;originalsz = addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    myproc()-&gt;sz+=n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(growproc(n)&lt;<span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// if(growproc(n) &lt; 0)</span></span><br><span class="line">  <span class="comment">//   return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h1><p>On a page fault on these not allocated address , the kernel allocates new pa and map into the page table.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">15</span> || r_scause() == <span class="number">13</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= p-&gt;sz)</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (va&lt;p-&gt;originalsz-PGSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//printf("page fault %p\n",va);</span></span><br><span class="line">      <span class="keyword">char</span> *mem;</span><br><span class="line">      va = PGROUNDDOWN(va);</span><br><span class="line">      mem = kalloc();</span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, PTE_W | PTE_X | PTE_R | PTE_U);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h1><p>According to the hints!</p><blockquote><ul><li>Handle negative sbrk() arguments.</li><li>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</li><li>Handle the parent-to-child memory copy in fork() correctly.</li><li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li><li>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</li><li>Handle faults on the invalid page below the user stack.</li></ul></blockquote><ul><li>The negative argument is a little tricky ,we directly call <code>growproc</code></li><li>higher va or lower va will be invalid , the higher va is simple to find ,the lower va is under the stack which are the guard page and text and  data </li><li>In <code>fork</code>  actually in <code>uvmcopy</code> , for the  not exist page and not valid mapping , we ignore !</li><li>For the system call <code>read and write</code> , will happen “ page fault ” in <code>walkaddr</code> ,but not go to the <code>usertrap</code>,we need to handle it in <code>walkaddr</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">walkaddr(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>||(*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">if</span> (va &gt;=myproc()-&gt;sz||va&lt;myproc()-&gt;originalsz-PGSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">      pte = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *mem;</span><br><span class="line">    va = PGROUNDDOWN(va); </span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      pte = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      mappages(pagetable, va, PGSIZE, (uint64)mem, PTE_W | PTE_X | PTE_R | PTE_U);</span><br><span class="line">      pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// if ((*pte &amp; PTE_V) == 0)</span></span><br><span class="line">  <span class="comment">//   return 0;</span></span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>||(*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.<strong>The course lab site</strong> :<a href="https://pdos.csail.mit.edu/6.828/2020/labs/lazy.html">MIT 6.S081 Lazy Lab</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lazy-Lab&quot;&gt;&lt;a href=&quot;#Lazy-Lab&quot; class=&quot;headerlink&quot; title=&quot;Lazy Lab&quot;&gt;&lt;/a&gt;Lazy Lab&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;One of the many neat tricks an O/</summary>
      
    
    
    
    <category term="6.S081" scheme="https://walkerzf.github.io/categories/6-S081/"/>
    
    
    <category term="Lab" scheme="https://walkerzf.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Traps Lab</title>
    <link href="https://walkerzf.github.io/2020/10/28/TrapLab/"/>
    <id>https://walkerzf.github.io/2020/10/28/TrapLab/</id>
    <published>2020-10-28T12:00:00.000Z</published>
    <updated>2020-11-22T11:04:23.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trap-Lab"><a href="#Trap-Lab" class="headerlink" title="Trap Lab"></a>Trap Lab</h1><p>This lab explores how system calls are implemented using traps.</p><h1 id="Part-1-Assembly"><a href="#Part-1-Assembly" class="headerlink" title="Part 1 Assembly"></a>Part 1 Assembly</h1><p>This part is a warm-up exercise  to let you know a little more about Risc-v Assemble.</p><h1 id="Part-2-Backtrace"><a href="#Part-2-Backtrace" class="headerlink" title="Part 2  Backtrace"></a>Part 2  Backtrace</h1><p>A helper function in kernel . <code>BackTrace</code> helps us to print  a list of functions calls on the stack. According to the hints ,we do it step by step. Using the <code>r-tp</code> to get the  frame pointer of the current stack frame .</p><p>Note that the return address lives at a fixed offset (-8) from the frame pointer of a stack frame, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.  </p><p>The operation on the pointer.</p><p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address.  If the <code>fp</code> not satisfied the one PGSIZE , the <code>fp</code> will at the bottom of the call stack</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// lab4 part2</span></span><br><span class="line"><span class="comment">// backtrace</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 * currentfp =  (uint64 *)r_fp();</span><br><span class="line">  uint64 up ;</span><br><span class="line">  uint64 down ; </span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, *(currentfp<span class="number">-1</span>));</span><br><span class="line">    currentfp = (uint64*)(*(currentfp<span class="number">-2</span>));</span><br><span class="line">    up =  PGROUNDUP((uint64)currentfp);</span><br><span class="line">    down = PGROUNDDOWN((uint64)currentfp);  </span><br><span class="line">  &#125; <span class="keyword">while</span> (up-down==PGSIZE);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Part-3-Alarm"><a href="#Part-3-Alarm" class="headerlink" title="Part 3 Alarm"></a>Part 3 Alarm</h1><p>In this part , we want to add two system call  to xv6 . </p><p>Once in user code we  invoke system call ,  The mode will convert from <code>user mode</code> - &gt; <code>kernel mode</code> .`` ecall-&gt;usertrap-&gt;usertrapret-&gt;sret<code>,  after exiting the kernel mode ,the</code>pc<code>will jump to the</code>p-&gt;tramframe-&gt;epc<code>which saves the</code>sepc<code>.  So we know when to call</code>handler<code>function (time interrupt) , after</code>interrupt <code>we need to jump the</code>handler<code>function ,which means we  fix the value in</code>p-&gt;tramframe-&gt;epc` . </p><p>The <code>function pointer</code> aka the address of the function ,aka the value of <code>epc</code>.</p><p>In user code , we invoke <code>sigalarm</code>. In this system call implementation, we need to save the <code>interval</code> and <code>function pointer</code> in <code>proc</code> structure , an return user  code ,  the <code>p-&gt;tramfram-&gt;epc</code> will be the next of <code>ecall</code>. </p><p>When we have a timer interrupt ,we need  the <code>epc</code> be the <code>function pointer</code> , for resuming the  interrupted user code . Because usually  we return the interrupted user code, this time ,we need to jump to<code>handler</code> function ,we need to reserve the <code>p-&gt;tramframe-&gt;*</code>  and change the <code>p-&gt;tramframe-&gt;epc</code> be the <code>function pointer</code> . In <code>handler</code> function ,we invoke <code>sigreturn</code> system call. In this implementation , we restore the saved registers  when  interrupted ,and jump to the  original <code>p-&gt;tramframe-&gt;epc</code> resume the user code .</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (which_dev == <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    p-&gt;pastedticks++;</span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;pastedticks &gt; <span class="number">0</span>) &amp;&amp; (p-&gt;pastedticks == p-&gt;interval))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;permisson == <span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        p-&gt;permisson = <span class="number">0</span>;</span><br><span class="line">        p-&gt;epc = p-&gt;trapframe-&gt;epc;</span><br><span class="line">        p-&gt;ra = p-&gt;trapframe-&gt;ra;</span><br><span class="line">        p-&gt;sp = p-&gt;trapframe-&gt;sp;</span><br><span class="line">        p-&gt;gp = p-&gt;trapframe-&gt;gp;</span><br><span class="line">        p-&gt;tp = p-&gt;trapframe-&gt;tp;</span><br><span class="line">        p-&gt;t0 = p-&gt;trapframe-&gt;t0;</span><br><span class="line">        p-&gt;t1 = p-&gt;trapframe-&gt;t1;</span><br><span class="line">        p-&gt;t2 = p-&gt;trapframe-&gt;t2;</span><br><span class="line">        p-&gt;s0 = p-&gt;trapframe-&gt;s0;</span><br><span class="line">        p-&gt;s1 = p-&gt;trapframe-&gt;s1;</span><br><span class="line">        p-&gt;a0 = p-&gt;trapframe-&gt;a0;</span><br><span class="line">        p-&gt;a1 = p-&gt;trapframe-&gt;a1;</span><br><span class="line">        p-&gt;a2 = p-&gt;trapframe-&gt;a2;</span><br><span class="line">        p-&gt;a3 = p-&gt;trapframe-&gt;a3;</span><br><span class="line">        p-&gt;a4 = p-&gt;trapframe-&gt;a4;</span><br><span class="line">        p-&gt;a5 = p-&gt;trapframe-&gt;a5;</span><br><span class="line">        p-&gt;a6 = p-&gt;trapframe-&gt;a6;</span><br><span class="line">        p-&gt;a7 = p-&gt;trapframe-&gt;a7;</span><br><span class="line">        p-&gt;s2 = p-&gt;trapframe-&gt;s2;</span><br><span class="line">        p-&gt;s3 = p-&gt;trapframe-&gt;s3;</span><br><span class="line">        p-&gt;s4 = p-&gt;trapframe-&gt;s4;</span><br><span class="line">        p-&gt;s5 = p-&gt;trapframe-&gt;s5;</span><br><span class="line">        p-&gt;s6 = p-&gt;trapframe-&gt;s6;</span><br><span class="line">        p-&gt;s7 = p-&gt;trapframe-&gt;s7;</span><br><span class="line">        p-&gt;s8 = p-&gt;trapframe-&gt;s8;</span><br><span class="line">        p-&gt;s9 = p-&gt;trapframe-&gt;s9;</span><br><span class="line">        p-&gt;s10 = p-&gt;trapframe-&gt;s10;</span><br><span class="line">        p-&gt;s11 = p-&gt;trapframe-&gt;s11;</span><br><span class="line">        p-&gt;t3 = p-&gt;trapframe-&gt;t3;</span><br><span class="line">        p-&gt;t4 = p-&gt;trapframe-&gt;t4;</span><br><span class="line">        p-&gt;t5 = p-&gt;trapframe-&gt;t5;</span><br><span class="line">        p-&gt;t6 = p-&gt;trapframe-&gt;t6;</span><br><span class="line">        p-&gt;trapframe-&gt;epc = p-&gt;handler;</span><br><span class="line">        p-&gt;pastedticks = <span class="number">0</span>;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// added system call</span></span><br><span class="line">uint64</span><br><span class="line">sys_sigreturn(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  p-&gt;permisson = <span class="number">1</span>;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = p-&gt;epc;</span><br><span class="line">  p-&gt;trapframe-&gt;ra = p-&gt;ra;</span><br><span class="line">  p-&gt;trapframe-&gt;sp = p-&gt;sp;</span><br><span class="line">  p-&gt;trapframe-&gt;gp = p-&gt;gp;</span><br><span class="line">  p-&gt;trapframe-&gt;tp = p-&gt;tp;</span><br><span class="line">  p-&gt;trapframe-&gt;t0 = p-&gt;t0;</span><br><span class="line">  p-&gt;trapframe-&gt;t1 = p-&gt;t1;</span><br><span class="line">  p-&gt;trapframe-&gt;t2 = p-&gt;t2;</span><br><span class="line">  p-&gt;trapframe-&gt;s0 = p-&gt;s0;</span><br><span class="line">  p-&gt;trapframe-&gt;s1 = p-&gt;s1;</span><br><span class="line">  p-&gt;trapframe-&gt;a0 = p-&gt;a0;</span><br><span class="line">  p-&gt;trapframe-&gt;a1 = p-&gt;a1;</span><br><span class="line">  p-&gt;trapframe-&gt;a2 = p-&gt;a2;</span><br><span class="line">  p-&gt;trapframe-&gt;a3 = p-&gt;a3;</span><br><span class="line">  p-&gt;trapframe-&gt;a4 = p-&gt;a4;</span><br><span class="line">  p-&gt;trapframe-&gt;a5 = p-&gt;a5;</span><br><span class="line">  p-&gt;trapframe-&gt;a6 = p-&gt;a6;</span><br><span class="line">  p-&gt;trapframe-&gt;a7 = p-&gt;a7;</span><br><span class="line">  p-&gt;trapframe-&gt;s2 = p-&gt;s2;</span><br><span class="line">  p-&gt;trapframe-&gt;s3 = p-&gt;s3;</span><br><span class="line">  p-&gt;trapframe-&gt;s4 = p-&gt;s4;</span><br><span class="line">  p-&gt;trapframe-&gt;s5 = p-&gt;s5;</span><br><span class="line">  p-&gt;trapframe-&gt;s6 = p-&gt;s6;</span><br><span class="line">  p-&gt;trapframe-&gt;s7 = p-&gt;s7;</span><br><span class="line">  p-&gt;trapframe-&gt;s8 = p-&gt;s8;</span><br><span class="line">  p-&gt;trapframe-&gt;s9 = p-&gt;s9;</span><br><span class="line">  p-&gt;trapframe-&gt;s10 = p-&gt;s10;</span><br><span class="line">  p-&gt;trapframe-&gt;s11 = p-&gt;s11;</span><br><span class="line">  p-&gt;trapframe-&gt;t3 = p-&gt;t3;</span><br><span class="line">  p-&gt;trapframe-&gt;t4 = p-&gt;t4;</span><br><span class="line">  p-&gt;trapframe-&gt;t5 = p-&gt;t5;</span><br><span class="line">  p-&gt;trapframe-&gt;t6 = p-&gt;t6;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//added system call</span></span><br><span class="line">uint64</span><br><span class="line">sys_sigalarm(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;(p-&gt;interval)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;(p-&gt;handler)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Trap-Lab&quot;&gt;&lt;a href=&quot;#Trap-Lab&quot; class=&quot;headerlink&quot; title=&quot;Trap Lab&quot;&gt;&lt;/a&gt;Trap Lab&lt;/h1&gt;&lt;p&gt;This lab explores how system calls are impleme</summary>
      
    
    
    
    <category term="6.S081" scheme="https://walkerzf.github.io/categories/6-S081/"/>
    
    
    <category term="Lab" scheme="https://walkerzf.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Pgtbl Lab</title>
    <link href="https://walkerzf.github.io/2020/10/22/PgtblLab/"/>
    <id>https://walkerzf.github.io/2020/10/22/PgtblLab/</id>
    <published>2020-10-22T15:13:14.000Z</published>
    <updated>2020-11-22T11:04:23.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pgtbl-Lab"><a href="#Pgtbl-Lab" class="headerlink" title="Pgtbl Lab"></a>Pgtbl Lab</h1><p>  In this lab , we will explore the user page tables and kernel page table ,and modify or create a process‘s kernel page table to help simplify the functions that copy data from user space into the kernel space.</p><p>  The lab have three parts. Part 1  is simpler relatively,we need to print the <strong>valid</strong> <code>pte</code> in three-level page table. Part 2 and 3 can be seen as one part .In part 2 ,we need to copy a process’s page table which is identical to kernel page table ,and in part 3 ,we need to add user mapping to the process’s kernel page table .</p><h1 id="Part-1-print-a-page-table"><a href="#Part-1-print-a-page-table" class="headerlink" title="Part 1 print a page table"></a>Part 1 print a page table</h1><p>  In this part ,we need to print the first process ‘ page table ,so we can see the figure 1 ,which is the use address space .The user address space have several parts : <code>text</code>,<code>data</code> ,<code>guard page</code> , <code>stack</code>,<code>trampoline</code> and <code>trapframe</code> .</p><p>  From the function <code>freewalk</code> .which is recursively free page-table pages ,we can find that we need to recursively print the page table. And we have three-level depth page table , so we need a variable to record the depth of the recursion in the helper function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freewalk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">"freewalk: leaf"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span> *)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  We can have the function like these.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//heplerfunction for vmprint</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helpervmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (level &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V))&#123;</span><br><span class="line">      <span class="comment">//this pte pointer to a lower-level page table</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= level; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">".."</span>);</span><br><span class="line">        <span class="keyword">if</span> (j != level)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d: pte %p pa %p\n"</span>, i, pte, child);</span><br><span class="line">      helpervmprint((<span class="keyword">pagetable_t</span>)child, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//function to help print the contents of a page table</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"page table %p\n"</span>, pagetable);</span><br><span class="line">  helpervmprint(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  We can get the output like this. In the top-level page table ,we have two entry. The first entry corresponding 1GB address. In the bottom page table ,we have three entries  ,corresponding the <code>text and data</code> ,<code>guard page</code> and <code>stack</code>.  The second entry in top-level page table ,  corresponding the <code>trampoline</code> and <code>tramframe</code> . We have two interesting points.</p><ul><li>The reason about the <code>text and data</code> are mapped together not respectively only for simplicity.</li><li>The <code>trampoline</code>  and <code>tramframe</code> are mapped highest in va , but in page table ,they are in entry <code>255</code>,not in <code>511</code>,because  although the <code>riscv</code>  uses 39-bits,it actually uses 38 bits ( because  if we use the 39th bit ,the 40th 41th 42th ..etc should be set <strong>All for simplicity! But still support for the future!</strong>) , so in the top-level page table ,we only have 8 bits, the highest bit is <code>255</code>.</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line">..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line">.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line">.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line">.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line">.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line">..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line">.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line">.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000</span><br><span class="line">.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure></blockquote><p>We actually can print the <code>PTE_FLAG</code> for each valid pte.</p><h1 id="Part-2-A-kernel-page-table-per-process"><a href="#Part-2-A-kernel-page-table-per-process" class="headerlink" title="Part 2  A kernel page table per process"></a>Part 2  A kernel page table per process</h1><p>  The lab is vert time-consuming ,because we are doing kernel programming  which is difficult to track the bug  and easy to make error. The points we should pay attention to :</p><ul><li>The <code>xv6</code> code is specialized for  kernel page table </li><li>the kernel page table  init  <code>kvminit</code>  happens in <code>pricinit</code> and <code>virto_disc</code>.</li><li>the memory free-up</li></ul><p>In part 3 , we will add user mapping in process’s kernel page table  to allow the kernel to dereference  the user pointer. This scheme rely on the <strong>user virtual memory range not overlapping the range of the <code>va</code> that the kernel address uses for its own instructions and data .</strong><br>       Xv6 uses virtual addresses that start at zero for user address spaces, and luckily the kernel’s memory starts at higher addresses. <strong>However, this scheme does limit the maximum size of a user process to be less than the kernel’s lowest virtual address.</strong> After the kernel has booted, that address is 0xC000000 in xv6, the address of the <code>PLIC</code> registers .You’ll need to modify xv6 to prevent user processes from growing larger than the PLIC address.<br>        Through the calculating , the<code>kernel base</code> is in  entry 2 .And the <code>PLIC</code> is in entry zero ,anything above the <code>PLIC</code>.So any user mapping below the <code>PLIC</code> will be added into process’s kernel page table .And anything above that will be identical to the kernel page table.<br>         So the entry 1-511 we can share the same page table with the kernel page table . The entry zero should be unique in process’s kernel page table. This is called <code>share</code> solution.<br>        We could have the naive  <code>copy</code> solution , when we switch in  process , we copy the ,when we switch out ,we free up the page table .</p><h2 id="The-init-of-process-kernel-page-table"><a href="#The-init-of-process-kernel-page-table" class="headerlink" title="The init of process kernel page table"></a>The <code>init</code> of process kernel page table</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//share the 1-511 entry and map the entry zero  for process 's kernel page table init</span></span><br><span class="line"><span class="comment">// helper function </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvmmapkern</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"kvmmap"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// according to the Q&amp;A Lecture 7</span></span><br><span class="line"><span class="keyword">pagetable_t</span> kvmcreate()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> p = uvmcreate();</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">// we share the 1-511 entry</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p[i] = kernel_pagetable[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//we map the entry 0 and indentical to the kernel page table, add explicitly</span></span><br><span class="line">  <span class="comment">//we need a helper function because in kvminit function we do not</span></span><br><span class="line">  <span class="comment">//have an argument pagetable</span></span><br><span class="line"></span><br><span class="line">  kvmmapkern(p, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  kvmmapkern(p, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  kvmmapkern(p, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  kvmmapkern(p, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-clean-of-process-kernel-page-table"><a href="#The-clean-of-process-kernel-page-table" class="headerlink" title="The clean of process kernel page table"></a>The clean of process kernel page table</h2><p>When we free the  process’s kernel page table ,because entry 1-511 we share the same thing with the kernel page table ,so we do not need to free that memory . So we do free the lower level page table corresponding the entry zero. We can get <code>medium level</code> page table through the <code>pagetable[0]</code> ,  and free any valid pte  and corresponding <code>bottom level</code> page table .</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//according to the Q&amp;A Lecture 7</span></span><br><span class="line"><span class="comment">//a specialize kvmfree to match kvmcreate</span></span><br><span class="line"><span class="comment">//because we share the 1-511 ,only entry to consider is entry 0</span></span><br><span class="line"><span class="comment">//thus ,we only have one mid-level pagetable and possibly 512 bottom-level</span></span><br><span class="line"><span class="comment">//we never have free the PA which is pointed by the bottom-level pte</span></span><br><span class="line"><span class="comment">//because non were allocated by kvmcreate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvmfree</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> pte = pagetable[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">pagetable_t</span> level1 = (<span class="keyword">pagetable_t</span>)PTE2PA(pte);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> p = level1[i];</span><br><span class="line">    <span class="keyword">if</span> (p &amp; PTE_V)</span><br><span class="line">    &#123;</span><br><span class="line">      uint64 level2 = PTE2PA(p);</span><br><span class="line">      kfree((<span class="keyword">void</span> *) level2);</span><br><span class="line">      level1[i] =<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span> *)level1);</span><br><span class="line">  kfree((<span class="keyword">void</span> *)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>According to the hints in part 2 ,we need to fix the  <code>scheduler()</code> to load the process’s kernel page table when process is running ,when the no process is running ,the  <code>scheduler()</code> will use the kernel page table.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;kernelpgtbl));</span><br><span class="line">        sfence_vma();</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">        w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">        sfence_vma();</span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="Part-3-Add-user-mapping"><a href="#Part-3-Add-user-mapping" class="headerlink" title="Part 3 Add user mapping"></a>Part 3 Add user mapping</h1><p>Task: Simplify <code>copyin/copyinstr</code></p><p>Now for per process ,we have two page  table: one is user page table and another is a copy for kernel page table . We want to help the  simply <code>copyin</code> , when the kernel do not have user mapping ,the kernel needs to translate the <code>va =&gt; pa</code>  in software .Your task is to add user mapping to the process’s kernel page table so that the kernel can dereference the user pointers directly.</p><p><strong>Advantages:</strong></p><ul><li>Performance. When we need to move big bytes which can go out of <code>PGSIZE</code> , we need to <code>walkaddr</code> the <code>va</code> ,and move the <code>pa</code> .But when we have the correct user mapping ,we can using the page table.</li><li>We can manipulate the user data freely .Eg . when we need to fix a file in a data structure ,we may need copy in and copy out</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//according to Q&amp;A lecture 7</span></span><br><span class="line"><span class="comment">//copy ptes from the user pgtbl to process kernel pgtbl</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvmmapuser</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">pagetable_t</span> kpagetable, <span class="keyword">pagetable_t</span> upagetable, uint64 newsz, uint64 oldsz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="keyword">pte_t</span> *upte;</span><br><span class="line">  <span class="keyword">pte_t</span> *kpte;</span><br><span class="line">  <span class="keyword">if</span> (newsz &gt; PLIC)</span><br><span class="line">    panic(<span class="string">"kvmmapuser:newsz too large"</span>);</span><br><span class="line">  <span class="keyword">for</span> (va = oldsz; va &lt; newsz; va += PGSIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    upte = walk(upagetable, va, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="keyword">if</span> (upte == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"kvmmapuser :0x%x 0x%x\n"</span>, va, newsz);</span><br><span class="line">      panic(<span class="string">"kvmmapuser:not upte"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*upte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"kvmmapuser : no valid pte 0x%x 0x%x\n"</span>, va, newsz);</span><br><span class="line">      panic(<span class="string">"kvmmapuser:not valid upte"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    kpte = walk(kpagetable, va, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (kpte == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"kvmmapuser:no kpte"</span>);</span><br><span class="line">    *kpte = *upte;</span><br><span class="line">    *kpte &amp;= ~(PTE_U | PTE_W | PTE_X);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if newsz &lt; oldsz clear ptes , not necessary</span></span><br><span class="line">  <span class="comment">//check p-&gt;sz will not use thess ptes</span></span><br><span class="line">  <span class="keyword">for</span> (va = newsz; va &lt; oldsz; va += PGSIZE)&#123;</span><br><span class="line">    kpte = walk(kpagetable, va, <span class="number">1</span>);</span><br><span class="line">    *kpte &amp;= ~PTE_V;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When we add the <code>kvmmapuser</code> in <code>fork</code> , the third argument should be new process’s page table , because  when we fork many times, the old process may exit ,the old process ‘s page table may be cleaned up.</p><p><strong>The course lab site</strong> :<a href="https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html">MIT 6.S081 pgtbl</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Pgtbl-Lab&quot;&gt;&lt;a href=&quot;#Pgtbl-Lab&quot; class=&quot;headerlink&quot; title=&quot;Pgtbl Lab&quot;&gt;&lt;/a&gt;Pgtbl Lab&lt;/h1&gt;&lt;p&gt;  In this lab , we will explore the user p</summary>
      
    
    
    
    <category term="6.S081" scheme="https://walkerzf.github.io/categories/6-S081/"/>
    
    
    <category term="Lab" scheme="https://walkerzf.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>Introduction</title>
    <link href="https://walkerzf.github.io/2020/10/15/hello-world/"/>
    <id>https://walkerzf.github.io/2020/10/15/hello-world/</id>
    <published>2020-10-15T12:14:25.000Z</published>
    <updated>2020-11-22T11:04:23.464Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to Zat’s Blog.My name is Zhou Fang.</p><h2 id="Education"><a href="#Education" class="headerlink" title="Education"></a>Education</h2><ul><li>2015/9~2019/6    |    BeiHang University    |    Electrical Engineering    |    Bachelor</li><li>2019/9~                |     ZheJiang University    |   Electrical Engineering     |   Master</li></ul><h2 id="Experience"><a href="#Experience" class="headerlink" title="Experience"></a>Experience</h2><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul><li>[Github][<a href="https://github.com/walkerzf]">https://github.com/walkerzf]</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to Zat’s Blog.My name is Zhou Fang.&lt;/p&gt;
&lt;h2 id=&quot;Education&quot;&gt;&lt;a href=&quot;#Education&quot; class=&quot;headerlink&quot; title=&quot;Education&quot;&gt;&lt;/a&gt;Educatio</summary>
      
    
    
    
    <category term="intro" scheme="https://walkerzf.github.io/categories/intro/"/>
    
    
    <category term="intro" scheme="https://walkerzf.github.io/tags/intro/"/>
    
  </entry>
  
</feed>
